import{_ as e,c as o,o as l,U as a}from"./chunks/framework.BWp8c4Qg.js";const t="/blog/assets/Y3b6oi.CEnElSau.png",r="/blog/assets/9OfiAF.Yn5dPUpt.png",i="/blog/assets/IuoDmS.K3VYwYQQ.png",c="/blog/assets/PxFy1k.B5SPC_p7.png",p="/blog/assets/O8bw3R.LriAX99R.png",_=JSON.parse('{"title":"docker","description":"","frontmatter":{},"headers":[],"relativePath":"backend/devops/docker.md","filePath":"backend/devops/docker.md","lastUpdated":1711869862000}'),d={name:"backend/devops/docker.md"},s=a('<h1 id="docker" tabindex="-1">docker <a class="header-anchor" href="#docker" aria-label="Permalink to &quot;docker&quot;">​</a></h1><h2 id="docker简介" tabindex="-1">docker简介 <a class="header-anchor" href="#docker简介" aria-label="Permalink to &quot;docker简介&quot;">​</a></h2><p>Docker是应用程序与系统之间的隔离层。Docker让应用程序不必再关心主机环境，各个应用安装在docker镜像里面，docker引擎负责运行包裹了应用程序的docker镜像。</p><p>Docker的理念是让开发人员可以简单地把应用程序及依赖装载到容器中，然后轻松地部署到任何地方。docker有以下特点：</p><ul><li>Docker容器是轻量级的虚拟技术，占用更少系统资源。</li><li>使用 Docker容器，不同团队（如开发、测试，运维）之间更容易合作。</li><li>可以在任何地方部署 Docker 容器，比如在任何物理和虚拟机上，甚至在云上。</li><li>由于Docker容器非常轻量级，因此可扩展性很强。</li></ul><h3 id="docker-基本组成" tabindex="-1">Docker 基本组成 <a class="header-anchor" href="#docker-基本组成" aria-label="Permalink to &quot;Docker 基本组成&quot;">​</a></h3><p><img src="'+t+'" alt="img"></p><ul><li>镜像（image）：</li></ul><p>Docker 镜像就好比是一个目标，可以通过这个目标来创建容器服务，可以简单的理解为编程语言中的类。</p><ul><li>容器（container）:</li></ul><p>Docker 利用容器技术，独立运行一个或者一组应用，容器是通过镜像来创建的，在容器中可执行启动、停止、删除等基本命令，最终服务运行或者项目运行就是在容器中的，可理解为是类的实例。</p><ul><li>仓库（repository）:</li></ul><p>仓库就是存放镜像的地方！仓库分为公有仓库和私有仓库，类似Git。一般我们用的时候都是用国内docker镜像来加速。</p><h3 id="vm-跟-docker" tabindex="-1">VM 跟 Docker <a class="header-anchor" href="#vm-跟-docker" aria-label="Permalink to &quot;VM 跟 Docker&quot;">​</a></h3><p><img src="'+r+'" alt="img"></p><ul><li>虚拟机</li></ul><p>传统的虚拟机需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给他的资源将全部被占用。每一个虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p><ul><li>Docker</li></ul><p>容器技术是和我们的宿主机共享硬件资源及操作系统可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行</p><h2 id="docker运行原理" tabindex="-1">Docker运行原理 <a class="header-anchor" href="#docker运行原理" aria-label="Permalink to &quot;Docker运行原理&quot;">​</a></h2><p>Docker只提供一个运行环境，是不需要运行一个独立的 OS，容器中的系统内核跟宿主机的内核是公用的。docker容器本质上是宿主机的进程。他做了如下操作：</p><h3 id="namespace-进程隔离" tabindex="-1">namespace 进程隔离 <a class="header-anchor" href="#namespace-进程隔离" aria-label="Permalink to &quot;namespace 进程隔离&quot;">​</a></h3><p><img src="'+i+'" alt="img"></p><p>Linux Namespaces 机制提供一种进程资源隔离方案。PID、IPC、Network 等系统资源不再是全局性的，而是属于某个特定的Namespace。每个namespace下的资源对于其他 namespace 下的资源都是透明，不可见的。系统中可以同时存在两个进程号为0、1、2的进程，由于属于不同的namespace，所以它们之间并不冲突。</p><h3 id="cgroup-分配资源" tabindex="-1">CGroup 分配资源 <a class="header-anchor" href="#cgroup-分配资源" aria-label="Permalink to &quot;CGroup 分配资源&quot;">​</a></h3><p>Docker 通过 Cgroup 来控制容器使用的资源配额，一旦超过这个配额就发出OOM。配额主要包括 CPU、内存、磁盘三大方面， 基本覆盖了常见的资源配额和使用量控制。</p><p><img src="'+c+'" alt="img"></p><p>Cgroup 是 Control Groups 的缩写，是Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源(如 CPU、内存、磁盘 IO 等等)的机制，被 LXC(Linux container)、Docker 等很多项目用于实现进程资源控制。Cgroup 本身是提供将进程进行分组化管理的功能和接口的基础结构，I/O 或内存的分配控制等具体的资源管理是通过该功能来实现的，这些具体的资源 管理功能称为 Cgroup 子系统。</p><h3 id="chroot-跟-pivot-root-文件系统" tabindex="-1">chroot 跟 pivot_root 文件系统 <a class="header-anchor" href="#chroot-跟-pivot-root-文件系统" aria-label="Permalink to &quot;chroot 跟 pivot_root 文件系统&quot;">​</a></h3><p>chroot(change root file system)命令的功能是改变进程的根目录到指定的位置。比如我们现在有一个$HOME/test目录，想要把它作为一个 /bin/bash 进程的根目录。</p><ol><li>首先，创建一个 HOME/test/bin,lib64,lib</li><li>把bash命令拷贝到test目录对应的bin路径下 cp -v /bin/bash,ls $HOME/test/bin</li><li>把bash命令需要的所有so文件，也拷贝到test目录对应的lib路径下</li><li>执行chroot命令，告诉操作系统，我们将使用HOME/test /bin/bash</li></ol><ul><li>一致性</li></ul><p>由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着应用以及它运行所需要的所有依赖都被封装在了一起。有了容器镜像打包操作系统的能力，这个最基础的依赖环境也终于变成了应用沙盒的一部分。这就赋予了容器所谓的一致性：</p><p>无论在本地、云端，还是在一台任何地方的机器上，用户只需要解压打包好的容器镜像，那么这个应用运行所需要的完整的执行环境就被重现出来了。</p><ul><li>UnionFS 联合文件系统</li></ul><p>如何实现rootfs的高效可重复利用呢？Docker在镜像的设计中引入了层（layer）的概念。也就是说用户制作镜像的每一步操作都会生成一个层，也就是一个增量rootfs。介绍分层前我们先说个重要知识点，联合文件系统。</p><ul><li>layer 分层</li></ul><ol><li>只读层</li><li>可读写层</li><li>init层</li></ol><h2 id="docker网络" tabindex="-1">docker网络 <a class="header-anchor" href="#docker网络" aria-label="Permalink to &quot;docker网络&quot;">​</a></h2><ul><li>host: 和宿主机共享网络</li><li>none: 不配置网络</li><li>bridge: docker默认，也可自创</li><li>container: 容器网络连通，容器直接互联</li></ul><h2 id="docker命令" tabindex="-1">docker命令 <a class="header-anchor" href="#docker命令" aria-label="Permalink to &quot;docker命令&quot;">​</a></h2><p><img src="'+p+'" alt="img"></p><ul><li>FROM</li></ul><p>FROM 指令用于指定基础镜像，因此所有的 dockerfile 都必须使用 FROM 指令开头。FROM 指令可以出现多次，这样会构建多个镜像，每个镜像创建完成后，Docker 命令行界面会输出该镜像的 ID。常用指令格式为：<code>FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</code>。</p><ul><li>LABEL</li></ul><p>LABEL 指令可以用于指定镜像相关的元数据信息。格式为：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;</code>... 。</p><ul><li>ENV</li></ul><p>ENV 指令用于声明环境变量，声明好的环境变量可以在后面的指令中引用，引用格式为 <code>$variable_name 或 ${variable_name}</code> 。常用格式有以下两种：</p><ol><li>ENV <code>&lt;key&gt; &lt;value&gt;</code>：用于设置单个环境变量；</li><li>ENV <code>&lt;key&gt;=&lt;value&gt;</code> ... ：用于一次设置多个环境变量。</li></ol><ul><li>EXPOSE</li></ul><p>EXPOSE 用于指明容器对外暴露的端口号，格式为：<code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</code> ，您可以指定端口是侦听 TCP 还是 UDP，如果未指定协议，则默认为 TCP。</p><ul><li>WORKDIR</li></ul><p>WORKDIR 用于指明工作目录，它可以多次使用。如果指明的是相对路径，则它将相对于上一个WORKDIR指令的路径。</p><ul><li>COPY</li></ul><p>COPY 指令的常用格式为：COPY <code>&lt;src&gt;... &lt;dest&gt;</code>，用于将指定路径中的文件添加到新的镜像中，拷贝的目标路径可以不存在，程序会自动创建。</p><ul><li>RUN</li></ul><p>RUN 指令会在前一条命令创建出的镜像基础上再创建一个容器，并在容器中运行命令，在命令结束后提交该容器为新的镜像。它支持以下两种格式：</p><ol><li><code>RUN &lt;command&gt;</code>（shell 格式）</li><li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> (exec 格式)</li></ol><ul><li>CMD</li></ul><ol><li>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec 格式, 首选)</li><li>CMD [&quot;param1&quot;,&quot;param2&quot;] (作为 ENTRYPOINT 的默认参数)</li><li>CMD command param1 param2 (shell 格式)</li></ol><p>CMD 指令提供容器运行时的默认值，这些默认值可以是一条指令，也可以是一些参数。一个 dockerfile 中可以有多条 CMD 指令，但只有最后一条 CMD 指令有效。CMD 指令与 RUN 指令的命令格式相同，但作用不同：RUN 指令是在镜像的构建阶段用于产生新的镜像；而 CMD 指令则是在容器的启动阶段默认将 CMD 指令作为第一条执行的命令，如果用户在 docker run 时指定了新的命令参数，则会覆盖 CMD 指令中的命令。</p><ul><li>ENTRYPOINT</li></ul><p>ENTRYPOINT 指令 支持以下两种格式：</p><ol><li>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec 格式，首先)</li><li>ENTRYPOINT command param1 param2 (shell 格式)</li></ol><p>ENTRYPOINT 指令 和 CMD 指令类似，都可以让容器在每次启动时执行相同的命令。但不同的是 CMD 后面可以是参数也可以是命令，而 ENTRYPOINT 只能是命令；另外 docker run 命令提供的运行参数可以覆盖 CMD，但不能覆盖 ENTRYPOINT ，这意味着 ENTRYPOINT 指令上的命令一定会被执行。</p>',65),u=[s];function n(k,h,m,g,b,D){return l(),o("div",null,u)}const P=e(d,[["render",n]]);export{_ as __pageData,P as default};
