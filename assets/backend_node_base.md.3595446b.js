import{_ as s,c as a,o as n,a as l}from"./app.d2afdd46.js";const p='{"title":"node基础","description":"","frontmatter":{},"headers":[{"level":2,"title":"node的特点","slug":"node的特点"},{"level":3,"title":"异步IO模型","slug":"异步io模型"},{"level":3,"title":"事件与回调函数","slug":"事件与回调函数"},{"level":3,"title":"单线程","slug":"单线程"},{"level":3,"title":"node应用场景","slug":"node应用场景"},{"level":2,"title":"模块机制","slug":"模块机制"},{"level":3,"title":"CommonJS规范","slug":"commonjs规范"},{"level":3,"title":"Node中的模块实现","slug":"node中的模块实现"},{"level":2,"title":"异步IO","slug":"异步io"},{"level":3,"title":"异步I/O和非阻塞I/O","slug":"异步i-o和非阻塞i-o"},{"level":3,"title":"轮询技术","slug":"轮询技术"}],"relativePath":"backend/node/base.md"}',o={},e=[l('<h1 id="node基础" tabindex="-1">node基础 <a class="header-anchor" href="#node基础" aria-hidden="true">#</a></h1><p>读深入浅出node.js笔记与总结</p><h2 id="node的特点" tabindex="-1">node的特点 <a class="header-anchor" href="#node的特点" aria-hidden="true">#</a></h2><p>node 作为一个后端JavaScript的运行平台，保留了js的语法，基于作用域和原型链。</p><h3 id="异步io模型" tabindex="-1">异步IO模型 <a class="header-anchor" href="#异步io模型" aria-hidden="true">#</a></h3><p><img src="/blog/assets/O4PNgw.9b30a738.png" alt="img"></p><h3 id="事件与回调函数" tabindex="-1">事件与回调函数 <a class="header-anchor" href="#事件与回调函数" aria-hidden="true">#</a></h3><p>在node中创建一个网络服务</p><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> http </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">http</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">http</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createServer</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">req</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> res</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">var</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">postData</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;&#39;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">req</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">setEncoding</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">utf8</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">req</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">on</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">data</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">function</span><span style="color:#A6ACCD;"> (</span><span style="color:#FFCB6B;">trunk</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">postData</span><span style="color:#A6ACCD;"> += </span><span style="color:#F07178;">trunk</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">req</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">on</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">end</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">res</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">end</span><span style="color:#A6ACCD;">(</span><span style="color:#FFCB6B;">postData</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">listen</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">8080</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><p>node采用事件的编程方式来进行具有轻量级，松耦合，只关注事物点等优势，但是在多个异步任务的场景下面，事件与事件是相互隔离的。从事件编程演进来的就是回调函数，从而在流程控制当中，会存在一些问题。</p><h3 id="单线程" tabindex="-1">单线程 <a class="header-anchor" href="#单线程" aria-hidden="true">#</a></h3><p>node保持了js在浏览器中的单线程特点。在node中，js无法与其余线程进行状态共享，没有死锁，也没有线程上下文交换所带来的性能上面的开销。</p><p>单线程的弱点：</p><ul><li>无法利用多核CPU</li><li>大量计算占用CPU导致无法继续调用异步IO</li><li>错误会引起整个应用的退出</li></ul><p>不过node可以通过child_process来传递进程间的消息。通过Master-worker的管理方式，也可以很好的管理各个工作进程，以达到更高的健壮性。</p><h3 id="node应用场景" tabindex="-1">node应用场景 <a class="header-anchor" href="#node应用场景" aria-hidden="true">#</a></h3><ul><li>I/O密集型，擅长网络编程，node面向网络且擅长并行I/O,主要是利用了其事件循环的能力，资源占用极少。</li></ul><h2 id="模块机制" tabindex="-1">模块机制 <a class="header-anchor" href="#模块机制" aria-hidden="true">#</a></h2><h3 id="commonjs规范" tabindex="-1">CommonJS规范 <a class="header-anchor" href="#commonjs规范" aria-hidden="true">#</a></h3><ul><li>模块引用</li></ul><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> math </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">math</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span></code></pre></div><ul><li>模块导出</li></ul><div class="language-js"><pre><code><span class="line"><span style="color:#676E95;font-style:italic;">// 单个导出</span></span>\n<span class="line"><span style="color:#89DDFF;">exports.</span><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">xxx</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// 模块导出</span></span>\n<span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>\n<span class="line"></span></code></pre></div><h3 id="node中的模块实现" tabindex="-1">Node中的模块实现 <a class="header-anchor" href="#node中的模块实现" aria-hidden="true">#</a></h3><p>node中的模块实现经历了以下三个过程</p><ol><li>路径分析</li><li>文件定位</li><li>编译执行</li></ol><p>在node中，模块分为两类：一类是node提供的模块，称为核心模块；另外一类是用户编写的模块，称为文件模块。</p><ul><li>核心模块部分在Node源码过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块被直接加载进了内存，这部分核心模块引入的时候，速度会非常快。</li><li>文件模块则是在运行时动态加载，需要完整的进行路径分析，文件定位，编译执行，速度要慢。</li></ul><h4 id="优先从缓存加载" tabindex="-1">优先从缓存加载 <a class="header-anchor" href="#优先从缓存加载" aria-hidden="true">#</a></h4><p>node对引入的模块都会进行缓存，以减少二次引入时的开销。浏览器缓存的是文件，node缓存的是编译和执行后的对象。</p><h4 id="模块编译" tabindex="-1">模块编译 <a class="header-anchor" href="#模块编译" aria-hidden="true">#</a></h4><p>node中，每个文件模块都是一个对象</p><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Module</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">id</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> parent</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">id</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">id</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">exports</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{}</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">parent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">parent</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">parent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">parent</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">children</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">parent</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">children</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">)</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">filename</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">loaded</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">children</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> []</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><h2 id="异步io" tabindex="-1">异步IO <a class="header-anchor" href="#异步io" aria-hidden="true">#</a></h2><p><img src="/blog/assets/MPtFEE.832fcd60.png" alt="img"></p><ol><li>利用单线程，远离多线程死锁，状态同步等问题。</li><li>利用异步I/O，让单线程远离阻塞，可以更好的使用CPU</li></ol><h3 id="异步i-o和非阻塞i-o" tabindex="-1">异步I/O和非阻塞I/O <a class="header-anchor" href="#异步i-o和非阻塞i-o" aria-hidden="true">#</a></h3><blockquote><p>阻塞I/O</p></blockquote><p>阻塞I/O的特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。</p><p><img src="/blog/assets/qEcHIB.2dac6926.png" alt="img"></p><blockquote><p>非阻塞I/O</p></blockquote><h3 id="轮询技术" tabindex="-1">轮询技术 <a class="header-anchor" href="#轮询技术" aria-hidden="true">#</a></h3><ul><li>read：通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据之前，CPU一直耗用在等待上。</li></ul><p><img src="/blog/assets/wHAQo9.9ff0789e.png" alt="img"></p><ul><li>select: 它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断。</li></ul><p><img src="/blog/assets/Ow2JID.2b4148f7.png" alt="img"></p><ul><li>epoll：该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将其唤醒。它真实的利用了事件通知、执行回调的方式。</li></ul><p><img src="/blog/assets/4zSGA0.38ac5b9b.png" alt="img"></p>',48)];var t=s(o,[["render",function(s,l,p,o,t,r){return n(),a("div",null,e)}]]);export{p as __pageData,t as default};
