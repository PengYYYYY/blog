import{_ as s,c as a,o as n,U as l}from"./chunks/framework.B3hHBZKV.js";const p="/blog/assets/O4PNgw.DEFB7aM0.png",e="/blog/assets/MPtFEE.Cg7F74Df.png",o="/blog/assets/qEcHIB._cxUqRu6.png",r="/blog/assets/wHAQo9.DLeEfyPV.png",t="/blog/assets/Ow2JID.Bda3yPuC.png",c="/blog/assets/4zSGA0.Dn_M799p.png",E=JSON.parse('{"title":"node基础","description":"","frontmatter":{},"headers":[],"relativePath":"backend/node/base.md","filePath":"backend/node/base.md","lastUpdated":1708530745000}'),i={name:"backend/node/base.md"},D=l('<h1 id="node基础" tabindex="-1">node基础 <a class="header-anchor" href="#node基础" aria-label="Permalink to &quot;node基础&quot;">​</a></h1><p>读深入浅出 node.js 笔记与总结</p><h2 id="node的特点" tabindex="-1">node的特点 <a class="header-anchor" href="#node的特点" aria-label="Permalink to &quot;node的特点&quot;">​</a></h2><p>node 作为一个后端 JavaScript 的运行平台，保留了 js 的语法，基于作用域和原型链。</p><h3 id="异步io模型" tabindex="-1">异步IO模型 <a class="header-anchor" href="#异步io模型" aria-label="Permalink to &quot;异步IO模型&quot;">​</a></h3><p><img src="'+p+`" alt="img"></p><h3 id="事件与回调函数" tabindex="-1">事件与回调函数 <a class="header-anchor" href="#事件与回调函数" aria-label="Permalink to &quot;事件与回调函数&quot;">​</a></h3><p>在 node 中创建一个网络服务</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#BABED8;"> http </span><span style="color:#89DDFF;">=</span><span style="color:#82AAFF;"> require</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">http</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">http</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createServer</span><span style="color:#BABED8;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">req</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;font-style:italic;"> res</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#FFCB6B;">  var</span><span style="color:#F07178;"> postData</span><span style="color:#89DDFF;"> =</span><span style="color:#89DDFF;"> &#39;&#39;</span></span>
<span class="line"><span style="color:#FFCB6B;">  req</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">setEncoding</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">utf8</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#FFCB6B;">  req</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">on</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">data</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#FFCB6B;"> function</span><span style="color:#BABED8;"> (</span><span style="color:#FFCB6B;">trunk</span><span style="color:#BABED8;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#FFCB6B;">    postData</span><span style="color:#BABED8;"> += </span><span style="color:#F07178;">trunk</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">  }</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#FFCB6B;">  req</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">on</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">end</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#FFCB6B;"> function</span><span style="color:#89DDFF;"> ()</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#FFCB6B;">    res</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">end</span><span style="color:#BABED8;">(</span><span style="color:#FFCB6B;">postData</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">  }</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">listen</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">8080</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>node 采用事件的编程方式来进行具有轻量级，松耦合，只关注事物点等优势，但是在多个异步任务的场景下面，事件与事件是相互隔离的。从事件编程演进来的就是回调函数，从而在流程控制当中，会存在一些问题。</p><h3 id="单线程" tabindex="-1">单线程 <a class="header-anchor" href="#单线程" aria-label="Permalink to &quot;单线程&quot;">​</a></h3><p>node 保持了 js 在浏览器中的单线程特点。在 node 中，js 无法与其余线程进行状态共享，没有死锁，也没有线程上下文交换所带来的性能上面的开销。</p><p>单线程的弱点：</p><ul><li>无法利用多核 CPU</li><li>大量计算占用 CPU 导致无法继续调用异步 IO</li><li>错误会引起整个应用的退出</li></ul><p>不过 node 可以通过 child_process 来传递进程间的消息。通过 Master-worker 的管理方式，也可以很好的管理各个工作进程，以达到更高的健壮性。</p><h3 id="node应用场景" tabindex="-1">node应用场景 <a class="header-anchor" href="#node应用场景" aria-label="Permalink to &quot;node应用场景&quot;">​</a></h3><ul><li>I/O 密集型，擅长网络编程，node 面向网络且擅长并行 I/O,主要是利用了其事件循环的能力，资源占用极少。</li></ul><h2 id="模块机制" tabindex="-1">模块机制 <a class="header-anchor" href="#模块机制" aria-label="Permalink to &quot;模块机制&quot;">​</a></h2><h3 id="commonjs-规范" tabindex="-1">CommonJS 规范 <a class="header-anchor" href="#commonjs-规范" aria-label="Permalink to &quot;CommonJS 规范&quot;">​</a></h3><ul><li>模块引用</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#BABED8;"> math </span><span style="color:#89DDFF;">=</span><span style="color:#82AAFF;"> require</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">math</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>模块导出</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 单个导出</span></span>
<span class="line"><span style="color:#89DDFF;">exports.</span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;"> =</span><span style="color:#C792EA;"> function</span><span style="color:#89DDFF;">()</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#BABED8;">  xxx</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 模块导出</span></span>
<span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#89DDFF;"> =</span><span style="color:#89DDFF;"> {}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="node-中的模块实现" tabindex="-1">Node 中的模块实现 <a class="header-anchor" href="#node-中的模块实现" aria-label="Permalink to &quot;Node 中的模块实现&quot;">​</a></h3><p>node 中的模块实现经历了以下三个过程</p><ol><li>路径分析</li><li>文件定位</li><li>编译执行</li></ol><p>在 node 中，模块分为两类：一类是 node 提供的模块，称为核心模块；另外一类是用户编写的模块，称为文件模块。</p><ul><li>核心模块部分在 Node 源码过程中，编译进了二进制执行文件。在 node 进程启动时，部分核心模块被直接加载进了内存，这部分核心模块引入的时候，速度会非常快。</li><li>文件模块则是在运行时动态加载，需要完整的进行路径分析，文件定位，编译执行，速度要慢。</li></ul><h4 id="优先从缓存加载" tabindex="-1">优先从缓存加载 <a class="header-anchor" href="#优先从缓存加载" aria-label="Permalink to &quot;优先从缓存加载&quot;">​</a></h4><p>node 对引入的模块都会进行缓存，以减少二次引入时的开销。浏览器缓存的是文件，node 缓存的是编译和执行后的对象。</p><h4 id="模块编译" tabindex="-1">模块编译 <a class="header-anchor" href="#模块编译" aria-label="Permalink to &quot;模块编译&quot;">​</a></h4><p>node 中，每个文件模块都是一个对象</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#82AAFF;"> Module</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">id</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;font-style:italic;"> parent</span><span style="color:#89DDFF;">)</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#89DDFF;">  this.</span><span style="color:#BABED8;">id</span><span style="color:#89DDFF;"> =</span><span style="color:#BABED8;"> id</span></span>
<span class="line"><span style="color:#89DDFF;">  this.</span><span style="color:#BABED8;">exports</span><span style="color:#89DDFF;"> =</span><span style="color:#89DDFF;"> {}</span></span>
<span class="line"><span style="color:#89DDFF;">  this.</span><span style="color:#BABED8;">parent</span><span style="color:#89DDFF;"> =</span><span style="color:#BABED8;"> parent</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">  if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">parent</span><span style="color:#89DDFF;"> &amp;&amp;</span><span style="color:#BABED8;"> parent</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">children</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    parent</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">children</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">  }</span></span>
<span class="line"><span style="color:#89DDFF;">  this.</span><span style="color:#BABED8;">filename</span><span style="color:#89DDFF;"> =</span><span style="color:#89DDFF;"> null</span></span>
<span class="line"><span style="color:#89DDFF;">  this.</span><span style="color:#BABED8;">loaded</span><span style="color:#89DDFF;"> =</span><span style="color:#FF9CAC;"> false</span></span>
<span class="line"><span style="color:#89DDFF;">  this.</span><span style="color:#BABED8;">children</span><span style="color:#89DDFF;"> =</span><span style="color:#F07178;"> []</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="异步io" tabindex="-1">异步IO <a class="header-anchor" href="#异步io" aria-label="Permalink to &quot;异步IO&quot;">​</a></h2><p><img src="`+e+'" alt="img"></p><ol><li>利用单线程，远离多线程死锁，状态同步等问题。</li><li>利用异步 I/O，让单线程远离阻塞，可以更好的使用 CPU</li></ol><h3 id="异步-i-o-和非阻塞-i-o" tabindex="-1">异步 I/O 和非阻塞 I/O <a class="header-anchor" href="#异步-i-o-和非阻塞-i-o" aria-label="Permalink to &quot;异步 I/O 和非阻塞 I/O&quot;">​</a></h3><blockquote><p>阻塞 I/O</p></blockquote><p>阻塞 I/O 的特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。</p><p><img src="'+o+'" alt="img"></p><blockquote><p>非阻塞I/O</p></blockquote><h3 id="轮询技术" tabindex="-1">轮询技术 <a class="header-anchor" href="#轮询技术" aria-label="Permalink to &quot;轮询技术&quot;">​</a></h3><ul><li>read：通过重复调用来检查 I/O 的状态来完成完整数据的读取。在得到最终数据之前，CPU 一直耗用在等待上。</li></ul><p><img src="'+r+'" alt="img"></p><ul><li>select: 它是在 read 的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断。</li></ul><p><img src="'+t+'" alt="img"></p><ul><li>epoll：该方案是 Linux 下效率最高的 I/O 事件通知机制，在进入轮询的时候如果没有检查到 I/O 事件，将会进行休眠，直到事件发生将其唤醒。它真实的利用了事件通知、执行回调的方式。</li></ul><p><img src="'+c+'" alt="img"></p>',48),F=[D];function y(d,u,b,B,h,m){return n(),a("div",null,F)}const C=s(i,[["render",y]]);export{E as __pageData,C as default};
