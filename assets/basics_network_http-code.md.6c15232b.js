import{_ as e,o as a,c as i,a as t}from"./app.af1c1bf7.js";const f=JSON.parse('{"title":"http code","description":"","frontmatter":{},"headers":[{"level":2,"title":"100x","slug":"_100x","link":"#_100x","children":[{"level":3,"title":"100 Continue","slug":"_100-continue","link":"#_100-continue","children":[]},{"level":3,"title":"101 Switching Protocols","slug":"_101-switching-protocols","link":"#_101-switching-protocols","children":[]}]},{"level":2,"title":"200x","slug":"_200x","link":"#_200x","children":[{"level":3,"title":"200 OK","slug":"_200-ok","link":"#_200-ok","children":[]},{"level":3,"title":"201 Created","slug":"_201-created","link":"#_201-created","children":[]},{"level":3,"title":"202 Accepted","slug":"_202-accepted","link":"#_202-accepted","children":[]},{"level":3,"title":"204 No Content","slug":"_204-no-content","link":"#_204-no-content","children":[]}]},{"level":2,"title":"300x","slug":"_300x","link":"#_300x","children":[{"level":3,"title":"301 Moved Permanently","slug":"_301-moved-permanently","link":"#_301-moved-permanently","children":[]},{"level":3,"title":"302 Found","slug":"_302-found","link":"#_302-found","children":[]},{"level":3,"title":"303 See Other","slug":"_303-see-other","link":"#_303-see-other","children":[]},{"level":3,"title":"304 Not Modified","slug":"_304-not-modified","link":"#_304-not-modified","children":[]},{"level":3,"title":"Last-Modified 和 If-Modified-Since","slug":"last-modified-和-if-modified-since","link":"#last-modified-和-if-modified-since","children":[]},{"level":3,"title":"ETag 和 If-None-Match","slug":"etag-和-if-none-match","link":"#etag-和-if-none-match","children":[]},{"level":3,"title":"307 Temporary Redirect","slug":"_307-temporary-redirect","link":"#_307-temporary-redirect","children":[]},{"level":3,"title":"308 Permanent Redirect","slug":"_308-permanent-redirect","link":"#_308-permanent-redirect","children":[]},{"level":3,"title":"300x总结","slug":"_300x总结","link":"#_300x总结","children":[]}]},{"level":2,"title":"400x","slug":"_400x","link":"#_400x","children":[{"level":3,"title":"400 Bad Request","slug":"_400-bad-request","link":"#_400-bad-request","children":[]},{"level":3,"title":"401 Unauthorized","slug":"_401-unauthorized","link":"#_401-unauthorized","children":[]},{"level":3,"title":"403 Forbidden","slug":"_403-forbidden","link":"#_403-forbidden","children":[]},{"level":3,"title":"404 Not Found","slug":"_404-not-found","link":"#_404-not-found","children":[]},{"level":3,"title":"405 Method Not Allowed","slug":"_405-method-not-allowed","link":"#_405-method-not-allowed","children":[]},{"level":3,"title":"406 Not Acceptable","slug":"_406-not-acceptable","link":"#_406-not-acceptable","children":[]},{"level":3,"title":"409 Conflict","slug":"_409-conflict","link":"#_409-conflict","children":[]},{"level":3,"title":"410 Gone","slug":"_410-gone","link":"#_410-gone","children":[]},{"level":3,"title":"412 Precondition Failed","slug":"_412-precondition-failed","link":"#_412-precondition-failed","children":[]},{"level":3,"title":"413 Payload Too Large","slug":"_413-payload-too-large","link":"#_413-payload-too-large","children":[]},{"level":3,"title":"414 URI Too Long","slug":"_414-uri-too-long","link":"#_414-uri-too-long","children":[]},{"level":3,"title":"431 Request Header Fields Too Large","slug":"_431-request-header-fields-too-large","link":"#_431-request-header-fields-too-large","children":[]}]},{"level":2,"title":"500x","slug":"_500x","link":"#_500x","children":[{"level":3,"title":"500 Internal Server Error","slug":"_500-internal-server-error","link":"#_500-internal-server-error","children":[]},{"level":3,"title":"501 Not Implemented","slug":"_501-not-implemented","link":"#_501-not-implemented","children":[]},{"level":3,"title":"502 Bad Gateway","slug":"_502-bad-gateway","link":"#_502-bad-gateway","children":[]},{"level":3,"title":"503 Service Unavailable","slug":"_503-service-unavailable","link":"#_503-service-unavailable","children":[]},{"level":3,"title":"504 Gateway Timeout","slug":"_504-gateway-timeout","link":"#_504-gateway-timeout","children":[]}]}],"relativePath":"basics/network/http-code.md","lastUpdated":1690126819000}'),n={name:"basics/network/http-code.md"},d=t(`<h1 id="http-code" tabindex="-1">http code <a class="header-anchor" href="#http-code" aria-hidden="true">#</a></h1><h2 id="_100x" tabindex="-1">100x <a class="header-anchor" href="#_100x" aria-hidden="true">#</a></h2><p>这些状态代码表示临时的响应</p><h3 id="_100-continue" tabindex="-1">100 Continue <a class="header-anchor" href="#_100-continue" aria-hidden="true">#</a></h3><p>表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略.</p><p>为了让服务器检查请求的首部, 客户端必须在发送请求实体前, 在初始化请求中发送 Expect: 100-continue 首部并接收 100 Continue 响应状态码.</p><h4 id="expect" tabindex="-1">expect <a class="header-anchor" href="#expect" aria-hidden="true">#</a></h4><p>包含一个期望条件，表示服务器只有在满足此期望条件的情况下才能妥善地处理请求。</p><p>规范中只规定了一个期望条件，即 Expect: 100-continue, 对此服务器可以做出如下回应：</p><ul><li>100 如果消息头中的期望条件可以得到满足，使得请求可以顺利进行的话，</li><li>417 (Expectation Failed) 如果服务器不能满足期望条件的话；也可以是其他任意表示客户端错误的状态码（4xx）。</li></ul><h3 id="_101-switching-protocols" tabindex="-1">101 Switching Protocols <a class="header-anchor" href="#_101-switching-protocols" aria-hidden="true">#</a></h3><p>表示服务器应客户端升级协议的请求（Upgrade请求头）正在进行协议切换。 例:</p><div class="language-text line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">HTTP/1.1 101 Switching Protocols</span></span>
<span class="line"><span style="color:#A6ACCD;">Upgrade: websocket </span></span>
<span class="line"><span style="color:#A6ACCD;">Connection: Upgrade</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_200x" tabindex="-1">200x <a class="header-anchor" href="#_200x" aria-hidden="true">#</a></h2><p>表示请求成功</p><h3 id="_200-ok" tabindex="-1">200 OK <a class="header-anchor" href="#_200-ok" aria-hidden="true">#</a></h3><p>表明请求已经成功. 默认情况下状态码为200的响应可以被缓存。</p><h3 id="_201-created" tabindex="-1">201 Created <a class="header-anchor" href="#_201-created" aria-hidden="true">#</a></h3><p>表示请求已经被成功处理，并且创建了新的资源。新的资源在应答返回之前已经被创建。</p><h3 id="_202-accepted" tabindex="-1">202 Accepted <a class="header-anchor" href="#_202-accepted" aria-hidden="true">#</a></h3><p>表示服务器端已经收到请求消息，但是尚未进行处理。但是对于请求的处理确实无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。</p><h3 id="_204-no-content" tabindex="-1">204 No Content <a class="header-anchor" href="#_204-no-content" aria-hidden="true">#</a></h3><p>表示目前请求成功，但客户端不需要更新其现有页面。</p><p>使用惯例是，在 PUT 请求中进行资源更新，但是不需要改变当前展示给用户的页面，那么返回 204 No Content。如果新创建了资源，那么返回 201 Created 。如果页面需要更新以反映更新后的资源，那么需要返回 200 。</p><h2 id="_300x" tabindex="-1">300x <a class="header-anchor" href="#_300x" aria-hidden="true">#</a></h2><p>表示要完成请求，需要进一步操作.通常，这些状态代码用来重定向。</p><h3 id="_301-moved-permanently" tabindex="-1">301 Moved Permanently <a class="header-anchor" href="#_301-moved-permanently" aria-hidden="true">#</a></h3><p>永久重定向。说明请求的资源已经被移动到了由 Location 头部指定的 url 上，是固定的不会再改变。搜索引擎会根据该响应修正。</p><h3 id="_302-found" tabindex="-1">302 Found <a class="header-anchor" href="#_302-found" aria-hidden="true">#</a></h3><p>临时重定向。重定向状态码表明请求的资源被暂时的移动到了由 Location 头部指定的 URL 上。浏览器会重定向到这个URL，但是搜索引擎不会对该资源的链接进行更新。</p><h3 id="_303-see-other" tabindex="-1">303 See Other <a class="header-anchor" href="#_303-see-other" aria-hidden="true">#</a></h3><p>通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面。比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。303响应禁止被缓存。</p><p>303出现的原因：</p><ul><li>301和302本来在规范中是不允许重定向时改变请求方法的（将POST改为GET），但是许多浏览器却允许重定向时改变请求方法（这是一种不规范的实现）。</li><li>303的出现正是为了给上面的301，302这种行为作出个规范（将错就错吧），也就是允许重定向时改变请求方法。此外303响应禁止被缓存。</li></ul><h3 id="_304-not-modified" tabindex="-1">304 Not Modified <a class="header-anchor" href="#_304-not-modified" aria-hidden="true">#</a></h3><p>说明无需再次传输请求的内容，也就是说可以使用缓存的内容。在请求中附带了头部信息： If-None-Match 或If-Modified-Since。</p><p>如果返回 200，响应会带有头部 Cache-Control, Content-Location, Date, ETag, Expires，和 Vary.</p><h3 id="last-modified-和-if-modified-since" tabindex="-1">Last-Modified 和 If-Modified-Since <a class="header-anchor" href="#last-modified-和-if-modified-since" aria-hidden="true">#</a></h3><ul><li>客户端请求一个文件（A）。 服务器返回文件A，并返回 Last-Modified。</li><li>客户端收到响应后，缓存文件A 和 Last-Modified。</li><li>客户端再次请求文件A 时，发现该文件有 Last-Modified ，那么 header 离包含 If-Modified-Since，这个时间就是缓存文件的 Last-Modified。</li><li>服务端收到请求，只需要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200</li></ul><p>If-Modified-Since 的主要缺点是只能精确到秒的级别，一旦在一秒内出现多次修改，是无法判断出已修改的状态。所以一般用在对时间不太敏感的静态资源。</p><h3 id="etag-和-if-none-match" tabindex="-1">ETag 和 If-None-Match <a class="header-anchor" href="#etag-和-if-none-match" aria-hidden="true">#</a></h3><ul><li>客户端请求一个文件（A）。 服务器返回文件A，并在给A加上一个 ETag。</li><li>客户端收到响应后，并将文件连同 ETag 一起缓存。</li><li>户再次请求文件A，会发送 If-None-Match，内容是缓存该文件A的 Etag 值</li><li>服务器检查该 ETag，和计算出来的 Etag 匹配，来判断文件是否未被修改。如果未修改就直接返回 304 和一个空的响应体。否则返回 200 和 文件。</li></ul><p>当与 If-Modified-Since 一同使用的时候，If-None-Match 优先级更高（假如服务器支持的话）</p><h3 id="_307-temporary-redirect" tabindex="-1">307 Temporary Redirect <a class="header-anchor" href="#_307-temporary-redirect" aria-hidden="true">#</a></h3><p>临时重定向。类似 302，区别在于能够确保请求方法和消息主体不会发生改变。</p><h3 id="_308-permanent-redirect" tabindex="-1">308 Permanent Redirect <a class="header-anchor" href="#_308-permanent-redirect" aria-hidden="true">#</a></h3><p>永久重定向。类似 301，区别在于能够确保请求方法和消息主体不会发生改变。</p><h3 id="_300x总结" tabindex="-1">300x总结 <a class="header-anchor" href="#_300x总结" aria-hidden="true">#</a></h3><h4 id="改变地址" tabindex="-1">改变地址 <a class="header-anchor" href="#改变地址" aria-hidden="true">#</a></h4><p>永久改变地址：301、308 临时改变地址：302/303、307</p><h4 id="改变请求方法" tabindex="-1">改变请求方法 <a class="header-anchor" href="#改变请求方法" aria-hidden="true">#</a></h4><p>允许改变请求：301、302 不允许：308、307</p><h4 id="对seo的友好性" tabindex="-1">对SEO的友好性 <a class="header-anchor" href="#对seo的友好性" aria-hidden="true">#</a></h4><p>301与302的区别：301表示搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。</p><h2 id="_400x" tabindex="-1">400x <a class="header-anchor" href="#_400x" aria-hidden="true">#</a></h2><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p><h3 id="_400-bad-request" tabindex="-1">400 Bad Request <a class="header-anchor" href="#_400-bad-request" aria-hidden="true">#</a></h3><p>表示由于语法无效，服务器无法理解该请求。客户端不应该在未经修改的情况下重复此请求。通常用于参数错误。</p><h3 id="_401-unauthorized" tabindex="-1">401 Unauthorized <a class="header-anchor" href="#_401-unauthorized" aria-hidden="true">#</a></h3><p>说明由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。</p><p>这个状态码会与 WWW-Authenticate 首部一起发送，其中包含有如何进行验证的信息。</p><h3 id="_403-forbidden" tabindex="-1">403 Forbidden <a class="header-anchor" href="#_403-forbidden" aria-hidden="true">#</a></h3><p>指的是服务器端有能力处理该请求，但是拒绝授权访问。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关（例如不正确的密码）</p><h3 id="_404-not-found" tabindex="-1">404 Not Found <a class="header-anchor" href="#_404-not-found" aria-hidden="true">#</a></h3><p>说明服务器端无法找到所请求的资源。返回该响应的链接通常称为坏链（broken link）或死链（dead link），它们会导向链接出错处理</p><h3 id="_405-method-not-allowed" tabindex="-1">405 Method Not Allowed <a class="header-anchor" href="#_405-method-not-allowed" aria-hidden="true">#</a></h3><p>表明服务器禁止了使用当前 HTTP 方法的请求。需要注意的是，GET 与 HEAD 两个方法不得被禁止，当然也不得返回状态码 405。</p><h3 id="_406-not-acceptable" tabindex="-1">406 Not Acceptable <a class="header-anchor" href="#_406-not-acceptable" aria-hidden="true">#</a></h3><p>表示服务器端不支持 Accept、Accept-Charset、Accept-Encoding、 Accept-Language header 所要求的。</p><h3 id="_409-conflict" tabindex="-1">409 Conflict <a class="header-anchor" href="#_409-conflict" aria-hidden="true">#</a></h3><p>表示请求与服务器端目标资源的当前状态相冲突。</p><p>冲突最有可能发生在对 PUT 请求的响应中。例如，当上传文件的版本比服务器上已存在的要旧，从而导致版本冲突的时候，那么就有可能收到状态码为 409 的响应。</p><h3 id="_410-gone" tabindex="-1">410 Gone <a class="header-anchor" href="#_410-gone" aria-hidden="true">#</a></h3><p>说明请求的内容在服务器上不存在了，同时是永久性的丢失。如果不清楚是否为永久或临时的丢失，应该使用404。</p><h3 id="_412-precondition-failed" tabindex="-1">412 Precondition Failed <a class="header-anchor" href="#_412-precondition-failed" aria-hidden="true">#</a></h3><p>表示客户端错误，意味着对于目标资源的访问请求被拒绝。这通常发生在采用除 GET 和 HEAD 之外的方法进行条件请求时，由首部字段 If-Unmodified-Since 或 If-None-Match 规定的先决条件不成立的情况下。</p><h3 id="_413-payload-too-large" tabindex="-1">413 Payload Too Large <a class="header-anchor" href="#_413-payload-too-large" aria-hidden="true">#</a></h3><p>表示请求主体的大小超过了服务器愿意或有能力处理的限度，服务器可能会（may）关闭连接以防止客户端继续发送该请求。</p><p>如果“超出限度”是暂时性的，服务器应该返回 Retry-After 首部字段，说明这是暂时性的，以及客户端可以在什么时间后重试。</p><h3 id="_414-uri-too-long" tabindex="-1">414 URI Too Long <a class="header-anchor" href="#_414-uri-too-long" aria-hidden="true">#</a></h3><p>表示客户端所请求的 URI 超过了服务器允许的范围。</p><h3 id="_431-request-header-fields-too-large" tabindex="-1">431 Request Header Fields Too Large <a class="header-anchor" href="#_431-request-header-fields-too-large" aria-hidden="true">#</a></h3><p>表示由于请求中的首部字段的值过大，服务器拒绝接受客户端的请求。客户端可以在缩减首部字段的体积后再次发送请求。</p><p>该响应码可以用于首部总体体积过大的情况，也可以用于单个首部体积过大的情况。</p><h2 id="_500x" tabindex="-1">500x <a class="header-anchor" href="#_500x" aria-hidden="true">#</a></h2><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p><h3 id="_500-internal-server-error" tabindex="-1">500 Internal Server Error <a class="header-anchor" href="#_500-internal-server-error" aria-hidden="true">#</a></h3><p>表示所请求的服务器遇到意外的情况并阻止其执行请求。</p><h3 id="_501-not-implemented" tabindex="-1">501 Not Implemented <a class="header-anchor" href="#_501-not-implemented" aria-hidden="true">#</a></h3><p>表示request header 里的 method 或 Content-* 时不被服务器支持，无法被处理。另，服务器必须支持的方法（即不会返回这个状态码的方法）只有 GET 和 HEAD。501 响应默认是可缓存的。</p><h3 id="_502-bad-gateway" tabindex="-1">502 Bad Gateway <a class="header-anchor" href="#_502-bad-gateway" aria-hidden="true">#</a></h3><p>表示作为网关或代理角色的服务器，从上游服务器（如node.js web server）中接收到的响应是无效的。</p><h3 id="_503-service-unavailable" tabindex="-1">503 Service Unavailable <a class="header-anchor" href="#_503-service-unavailable" aria-hidden="true">#</a></h3><p>表示服务器尚未处于可以接受请求的状态。通常造成这种情况的原因是由于服务器停机维护或者已超载。该种响应应该用于临时状况下，与之同时，在可行的情况下，应该在 Retry-After 首部字段中包含服务恢复的预期时间。</p><h3 id="_504-gateway-timeout" tabindex="-1">504 Gateway Timeout <a class="header-anchor" href="#_504-gateway-timeout" aria-hidden="true">#</a></h3><p>表示网关或者代理的服务器无法在规定的时间内获得想要的响应。</p>`,96),r=[d];function l(o,h,c,s,p,_){return a(),i("div",null,r)}const g=e(n,[["render",l]]);export{f as __pageData,g as default};
