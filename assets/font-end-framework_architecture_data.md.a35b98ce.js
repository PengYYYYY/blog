import{_ as e,c as a,o as r,a as t}from"./app.0a131282.js";const i='{"title":"数据流","description":"","frontmatter":{},"headers":[{"level":2,"title":"vue","slug":"vue"},{"level":3,"title":"数据响应式","slug":"数据响应式"},{"level":3,"title":"数据收集","slug":"数据收集"},{"level":2,"title":"react","slug":"react"},{"level":2,"title":"差异","slug":"差异"}],"relativePath":"font-end-framework/architecture/data.md"}',l={},d=[t('<h1 id="数据流" tabindex="-1">数据流 <a class="header-anchor" href="#数据流" aria-hidden="true">#</a></h1><p>双方数据流对比，</p><h2 id="vue" tabindex="-1">vue <a class="header-anchor" href="#vue" aria-hidden="true">#</a></h2><p>数据可变</p><h3 id="数据响应式" tabindex="-1">数据响应式 <a class="header-anchor" href="#数据响应式" aria-hidden="true">#</a></h3><ul><li><p>vue2 使用了核心api，Object.defineProperty，</p></li><li><p>vue3 使用了ES6 的 Proxy，对数据进行变化侦测，添加 getter 和 setter，这样就知道数据何时被读取和修改</p></li></ul><h3 id="数据收集" tabindex="-1">数据收集 <a class="header-anchor" href="#数据收集" aria-hidden="true">#</a></h3><p>核心是观察者模式</p><ul><li>Vue对于每个数据都收集了与之相关的依赖，这里的依赖其实就是一个对象，保存有该数据的旧值及数据变化后需要执行的函数。每个响应式的数据变化时会遍历通知其对应的每个依赖，依赖收到通知后会判断一下新旧值有没有发生变化，如果变化则执行回调函数响应数据变化（比如修改 dom）。</li></ul><h2 id="react" tabindex="-1">react <a class="header-anchor" href="#react" aria-hidden="true">#</a></h2><p>数据不可变</p><p>不可变数据计算数据diff，需要用特定的api去处罚数据的变化。</p><h2 id="差异" tabindex="-1">差异 <a class="header-anchor" href="#差异" aria-hidden="true">#</a></h2><p>vue为immutable的代表，react为mutable。</p>',14)];var h=e(l,[["render",function(e,t,i,l,h,u){return r(),a("div",null,d)}]]);export{i as __pageData,h as default};
