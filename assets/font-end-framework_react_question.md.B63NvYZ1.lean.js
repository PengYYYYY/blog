import{_ as a,c as n,R as e,o as l}from"./chunks/framework.3D9yNSa1.js";const d=JSON.parse('{"title":"React常见问题","description":"","frontmatter":{},"headers":[],"relativePath":"font-end-framework/react/question.md","filePath":"font-end-framework/react/question.md","lastUpdated":1725463910000}'),p={name:"font-end-framework/react/question.md"};function o(t,s,r,c,i,D){return l(),n("div",null,s[0]||(s[0]=[e(`<h1 id="react常见问题" tabindex="-1">React常见问题 <a class="header-anchor" href="#react常见问题" aria-label="Permalink to &quot;React常见问题&quot;">​</a></h1><h2 id="生命周期相关" tabindex="-1">生命周期相关 <a class="header-anchor" href="#生命周期相关" aria-label="Permalink to &quot;生命周期相关&quot;">​</a></h2><h3 id="挂载阶段" tabindex="-1">挂载阶段 <a class="header-anchor" href="#挂载阶段" aria-label="Permalink to &quot;挂载阶段&quot;">​</a></h3><p>挂载阶段也可以理解为初始化阶段，也就是把我们的组件插入到 DOM 中。</p><ul><li>constructor</li><li>getDerivedStateFromProps</li><li><s>UNSAFE_componentWillMount</s></li><li>render</li><li>(React Updates DOM and refs)</li><li>componentDidMount</li></ul><h4 id="constructor" tabindex="-1">constructor <a class="header-anchor" href="#constructor" aria-label="Permalink to &quot;constructor&quot;">​</a></h4><p>组件的构造函数，第一个被执行。显式定义构造函数时，需要在第一行执行 <code>super(props)</code>，否则不能再构造函数中拿到 <code>this</code>。</p><p>在构造函数中，我们一般会做两件事：</p><ul><li>初始化 state</li><li>对自定义方法进行 this 绑定</li></ul><h4 id="getderivedstatefromprops" tabindex="-1">getDerivedStateFromProps <a class="header-anchor" href="#getderivedstatefromprops" aria-label="Permalink to &quot;getDerivedStateFromProps&quot;">​</a></h4><p>是一个静态函数，所以不能在这里使用 this，也表明了 React 官方不希望调用方滥用这个生命周期函数。每当父组件引发当前组件的渲染过程时，getDerivedStateFromProps 都会被调用，这样我们有机会根据新的 props 和当前的 state 来调整一个新的 state。</p><p>这个函数会在收到新的 props，调用了 setState 或 forceUpdate 时被调用。</p><h4 id="render" tabindex="-1">render <a class="header-anchor" href="#render" aria-label="Permalink to &quot;render&quot;">​</a></h4><p>React 最核心的方法，class 组件中必须实现的方法。</p><p>当 render 被调用时，它会检查 <code>this.props</code> 和 <code>this.state</code> 的变化并返回一下类型之一：</p><ul><li>原生的 DOM，如 div</li><li>React 组件</li><li>数组或 Fragment</li><li>Portals（传送门）</li><li>字符串或数字，被渲染成文本节点</li><li>布尔值或 null，不会渲染任何东西</li></ul><h4 id="componentdidmount" tabindex="-1">componentDidMount <a class="header-anchor" href="#componentdidmount" aria-label="Permalink to &quot;componentDidMount&quot;">​</a></h4><p>在组件挂载之后立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。这个方法比较适合添加订阅的地方，如果添加了订阅，请记得在卸载的时候取消订阅。</p><p>你可以在 componentDidMount 里面直接调用 setState，它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前，如此保证了即使 render 了两次，用户也不会看到中间状态。</p><h3 id="更新阶段" tabindex="-1">更新阶段 <a class="header-anchor" href="#更新阶段" aria-label="Permalink to &quot;更新阶段&quot;">​</a></h3><p>更新阶段是指当组件的 props 发生了改变，或者组件内部调用了 setState 或者发生了 forceUpdate，这个阶段的过程包括：</p><ul><li>UNSAFE_componentWillReceiveProps</li><li>getDerivedStateFromProps</li><li>sholdComponentUpdate</li><li>UNSAFE_componentWIllUpdate</li><li>render</li><li>getSnapshotBeforeUpdate</li><li>(React Updates DOM and refs)</li><li>componentDidUpdate</li></ul><h4 id="shouldcomponentupdate" tabindex="-1">shouldComponentUpdate <a class="header-anchor" href="#shouldcomponentupdate" aria-label="Permalink to &quot;shouldComponentUpdate&quot;">​</a></h4><p>它有两个参数，根据此函数的返回值来判断是否重新进行渲染，首次渲染或者是当我们调用了 forceUpdate 时并不会触发此方法，此方法仅用于性能优化。</p><p>但是官方提倡我们使用内置的 PureComponent 而不是自己编写 shouldComponentUpdate。</p><h4 id="getsnapshotbeforeupdate" tabindex="-1">getSnapshotBeforeUpdate <a class="header-anchor" href="#getsnapshotbeforeupdate" aria-label="Permalink to &quot;getSnapshotBeforeUpdate&quot;">​</a></h4><p>这个生命周期函数发生在 render 之后，在更新之前，给了一个机会去获取 DOM 信息，计算得到并返回一个 snapshot，这个 snapshot 会作为 componentDidUpdate 第三个参数传入。</p><h4 id="componentdidupdate" tabindex="-1">componentDidUpdate <a class="header-anchor" href="#componentdidupdate" aria-label="Permalink to &quot;componentDidUpdate&quot;">​</a></h4><p>这个函数会在更新后被立即调用，首次渲染不会执行此方法。在这个函数中我们可以操作 DOM，可以发起请求，还可以 setState，但注意一定要用条件语句，否则会导致无限循环。</p><h3 id="卸载阶段" tabindex="-1">卸载阶段 <a class="header-anchor" href="#卸载阶段" aria-label="Permalink to &quot;卸载阶段&quot;">​</a></h3><h4 id="componentwillunmount" tabindex="-1">componentWillUnmount <a class="header-anchor" href="#componentwillunmount" aria-label="Permalink to &quot;componentWillUnmount&quot;">​</a></h4><p>这个生命周期函数会在组件卸载销毁之前被调用，我们可以在这里执行一些清除操作。不要在这里调用 setState，因为组件不会重新渲染。</p><h3 id="shouldcomponentupdate-的作用" tabindex="-1">shouldComponentUpdate 的作用 <a class="header-anchor" href="#shouldcomponentupdate-的作用" aria-label="Permalink to &quot;shouldComponentUpdate 的作用&quot;">​</a></h3><p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 DOM。因为 DOM 的描绘性能开销很大，如果可以在这个生命周期阶段做出更优化的 DOM diff 算法，可以极大地提升性能。</p><h2 id="渲染相关" tabindex="-1">渲染相关 <a class="header-anchor" href="#渲染相关" aria-label="Permalink to &quot;渲染相关&quot;">​</a></h2><h3 id="reactdiff" tabindex="-1">ReactDiff <a class="header-anchor" href="#reactdiff" aria-label="Permalink to &quot;ReactDiff&quot;">​</a></h3><p>由于 diff 操作本身会带来性能上的损耗，在 React 文档中提到过，即使最先进的算法中，将前后两棵树完全比对的算法复杂度为<code>O(n3)</code>，其中 n 为树中元素的数量。如果 React 使用了该算法，那么仅仅一千个元素的页面所需要执行的计算量就是十亿的量级，这无疑是无法接受的。为了降低算法的复杂度，React 的 diff 会预设三个限制：</p><ol><li>只对同级元素进行 diff 比对。如果一个元素节点在前后两次更新中跨越了层级，那么 React 不会尝试复用它</li><li>两个不同类型的元素会产生出不同的树。如果元素由 div 变成 p，React 会销毁 div 及其子孙节点，并新建 p 及其子孙节点</li><li>开发者可以通过 key 来暗示哪些子元素在不同的渲染下能保持稳定</li></ol><h3 id="react-中的-key-的作用" tabindex="-1">React 中的 key 的作用 <a class="header-anchor" href="#react-中的-key-的作用" aria-label="Permalink to &quot;React 中的 key 的作用&quot;">​</a></h3><ol><li>和 type 值一起来标记同级节点，当前元素的唯一性。</li><li>fiber 架构的唯一性</li></ol><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#676E95;font-style:italic;">&lt;!-- 更新前 --&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">  &lt;</span><span style="color:#F07178;">p</span><span style="color:#C792EA;"> key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ka</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">ka</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">  &lt;</span><span style="color:#F07178;">h3</span><span style="color:#C792EA;"> key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">song</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">song</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">he</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">&lt;!-- 更新后 --&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">  &lt;</span><span style="color:#F07178;">h3</span><span style="color:#C792EA;"> key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">song</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">song</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">h3</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">  &lt;</span><span style="color:#F07178;">p</span><span style="color:#C792EA;"> key</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ka</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">ka</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果没有 key，React 会认为 div 的第一个子节点由 p 变成 h3，第二个子节点由 h3 变成 p，则会销毁这两个节点并重新构造。但是当我们用 key 指明了节点前后对应关系后，React 知道 <code>key === &quot;ka&quot;</code> 的 p 更新后还在，所以可以复用该节点，只需要交换顺序。key 是 React 用来追踪哪些列表元素被修改、被添加或者被移除的辅助标志。</p><p>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React diff 算法中，React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重新渲染。同时，React 还需要借助 key 来判断元素与本地状态的关联关系。</p><h3 id="react-fiber" tabindex="-1">React Fiber <a class="header-anchor" href="#react-fiber" aria-label="Permalink to &quot;React Fiber&quot;">​</a></h3><ul><li>对于⼤大型项⽬目，组件树会很⼤大，这个时候递归遍历的成本就会很⾼高，会造成主线程被持续占⽤用，结果就是主线程上的布局、动画等周期性任务就⽆无法⽴立即得到处理理，造成视觉上的卡顿，影响⽤用户体验。</li><li>增量渲染(把渲染任务拆分成块，匀到多帧)</li><li>更新时能够暂停，终⽌，复⽤渲染任务</li><li>给不同类型的更新赋予优先级</li><li>并发⽅面新的基础能⼒</li></ul><h3 id="调用-setstate-之后发生了什么" tabindex="-1">调用 setState 之后发生了什么 <a class="header-anchor" href="#调用-setstate-之后发生了什么" aria-label="Permalink to &quot;调用 setState 之后发生了什么&quot;">​</a></h3><blockquote><p>状态合并</p></blockquote><p>在代码中调用 setState 函数之后，React 会将传入的参数与之前的状态进行合并，然后触发所谓的调和过程（Reconciliation）。</p><blockquote><p>调和</p></blockquote><p>经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会计算出新的树和老的树之间的差异，然后根据差异对界面进行最小化重新渲染。通过 diff 算法，React 能够精确制导哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p><h3 id="setstate-是同步还是异步" tabindex="-1">setState 是同步还是异步 <a class="header-anchor" href="#setstate-是同步还是异步" aria-label="Permalink to &quot;setState 是同步还是异步&quot;">​</a></h3><p>合成事件是批量异步执行的</p><p>原生事件是同步执行的</p><h2 id="开放性问题" tabindex="-1">开放性问题 <a class="header-anchor" href="#开放性问题" aria-label="Permalink to &quot;开放性问题&quot;">​</a></h2><h3 id="虚拟-dom" tabindex="-1">虚拟 dom <a class="header-anchor" href="#虚拟-dom" aria-label="Permalink to &quot;虚拟 dom&quot;">​</a></h3><h4 id="为什么要使用虚拟-dom-对象" tabindex="-1">为什么要使用虚拟 dom 对象 <a class="header-anchor" href="#为什么要使用虚拟-dom-对象" aria-label="Permalink to &quot;为什么要使用虚拟 dom 对象&quot;">​</a></h4><p>DOM 操作很慢，轻微的操作都可能导致页面重新排版，非常耗性能。相对于 DOM 对象，js 对象 处理起来更快，而且更简单。通过 diff 算法对比新旧 VDom 之间的差异，可以批量的、最小化的执行 dom 操作，从而提高性能。</p><p>在获取原生的 dom 节点后，dom 节点的属性极多，diff 后的成本较高。在使用虚拟 dom 后，只需要对我们用到的属性做 dif f即可。</p><h4 id="dom-的使用" tabindex="-1">dom 的使用 <a class="header-anchor" href="#dom-的使用" aria-label="Permalink to &quot;dom 的使用&quot;">​</a></h4><p>React中 用 JSX 语法描述视图，通过 babel-loader 转译后它们变为 React.createElement(...) 形 式，该函数将生成 VDom 来描述真实 dom。将来如果状态变化，VDom 将作出相应变化，再通过 diff 算法，对比新老 VDom 区别从而做出最终 dom 操作。</p><h4 id="jsx" tabindex="-1">jsx <a class="header-anchor" href="#jsx" aria-label="Permalink to &quot;jsx&quot;">​</a></h4><p>React 使用 JSX 来替代常规的 JavaScript。JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。使用 JSX 编写模板简单快速。JSX编译为 JavaScript 代码后进行了优化，执行更快。</p><h4 id="虚拟-dom-的缺点" tabindex="-1">虚拟 dom 的缺点 <a class="header-anchor" href="#虚拟-dom-的缺点" aria-label="Permalink to &quot;虚拟 dom 的缺点&quot;">​</a></h4><p>在首次渲染的情况下，需要多一层计算，然后渲染页面。会比组装原生 dom 节点然后直接 innerHtml 的性能差一下</p><h2 id="常见组件优化技术" tabindex="-1">常见组件优化技术 <a class="header-anchor" href="#常见组件优化技术" aria-label="Permalink to &quot;常见组件优化技术&quot;">​</a></h2><h3 id="使用-shouldcomponentupdate" tabindex="-1">使用 shouldComponentUpdate <a class="header-anchor" href="#使用-shouldcomponentupdate" aria-label="Permalink to &quot;使用 shouldComponentUpdate&quot;">​</a></h3><p>通过对比新老参数，来达到优化效果</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#82AAFF;">shouldComponentUpdate</span><span style="color:#BABED8;">(nextProps</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> nextState) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#C792EA;">  const</span><span style="color:#89DDFF;"> {</span><span style="color:#BABED8;"> xxx</span><span style="color:#89DDFF;"> }</span><span style="color:#89DDFF;"> =</span><span style="color:#89DDFF;"> this.</span><span style="color:#BABED8;">props</span></span>
<span class="line"><span style="color:#C792EA;">  const</span><span style="color:#89DDFF;"> {</span><span style="color:#F07178;"> xxx</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> oldXxx</span><span style="color:#89DDFF;"> }</span><span style="color:#89DDFF;"> =</span><span style="color:#BABED8;"> nextProps</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">  if</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">xxx</span><span style="color:#89DDFF;"> ==</span><span style="color:#BABED8;"> oldXxx</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#FF9CAC;"> false</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">  return</span><span style="color:#FF9CAC;"> true</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="purecomponentupdate" tabindex="-1">pureComponentUpdate <a class="header-anchor" href="#purecomponentupdate" aria-label="Permalink to &quot;pureComponentUpdate&quot;">​</a></h3><p>内部执行了一个shouldComponentUpdate，进行了一个前后值的浅比较。但是只能用作类组件。</p><p>React.Component 和 React.PureComponent很相似，两则的区别在于，PureComponent类帮我们以浅比较的方式对比props和state，实现了shouldComponentUpdate()函数，在某些情况下，使用PureComponent可以减少render函数的执行，提升性能。</p><p>PureComponent默认实现的shouldComponentUpdate()方法使用的是浅比较： 即值的比较或引用的比较, 不会进行深层次的对比，所以当props或state的值是引用类型时，即使对象的值改变了，但是对象的引用没变</p><p>PureComponent也会影响子组件</p><h3 id="react-memo" tabindex="-1">React.memo <a class="header-anchor" href="#react-memo" aria-label="Permalink to &quot;React.memo&quot;">​</a></h3><p>在函数组件中，原理是进行props比较</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> MemoComponent </span><span style="color:#89DDFF;">=</span><span style="color:#82AAFF;"> memo</span><span style="color:#BABED8;">(</span></span>
<span class="line"><span style="color:#BABED8;font-style:italic;">  props</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">    return</span><span style="color:#89DDFF;"> &lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">123</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">  },</span></span>
<span class="line"><span style="color:#89DDFF;">  (</span><span style="color:#BABED8;font-style:italic;">prevProps</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;font-style:italic;"> nextProps</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">    return</span><span style="color:#BABED8;"> preveProps</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">xxx</span><span style="color:#89DDFF;"> ===</span><span style="color:#BABED8;"> nextProps</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">xxx</span></span>
<span class="line"><span style="color:#89DDFF;">  }</span></span>
<span class="line"><span style="color:#BABED8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="usememo" tabindex="-1">useMemo <a class="header-anchor" href="#usememo" aria-label="Permalink to &quot;useMemo&quot;">​</a></h3><p>原理也是进行第二个依赖参数的比较，类似于vue中的computed</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> xxx </span><span style="color:#89DDFF;">=</span><span style="color:#82AAFF;"> useMemo</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">  return</span><span style="color:#BABED8;"> props</span><span style="color:#89DDFF;"> *</span><span style="color:#F78C6C;"> 2</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#BABED8;"> [props])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="usecallback" tabindex="-1">useCallback <a class="header-anchor" href="#usecallback" aria-label="Permalink to &quot;useCallback&quot;">​</a></h3><p>函数版本的useMemo,依赖项的对比。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> xxFn </span><span style="color:#89DDFF;">=</span><span style="color:#82AAFF;"> useCallback</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#BABED8;"> [propx])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="重点api" tabindex="-1">重点API <a class="header-anchor" href="#重点api" aria-label="Permalink to &quot;重点API&quot;">​</a></h2><h3 id="react-中-ref-的作用" tabindex="-1">React 中 ref 的作用 <a class="header-anchor" href="#react-中-ref-的作用" aria-label="Permalink to &quot;React 中 ref 的作用&quot;">​</a></h3><p>ref 是 React 提供的一种可以安全访问 DOM 元素或者某个组件实例的方式。</p><p>在类组件中使用 <code>createRef()</code>，在函数组件中使用 <code>useRef</code>或者 <code>forwardRef</code>。</p><p>使用类型</p><ul><li>createRef</li><li>forwardRef</li><li>useRef</li></ul><h3 id="cloneelement" tabindex="-1">cloneElement <a class="header-anchor" href="#cloneelement" aria-label="Permalink to &quot;cloneElement&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> ProcessInput </span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;"> ()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#BABED8;"> React</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">cloneElement</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">input</span><span style="color:#89DDFF;"> /&gt;,</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#F07178;">  placeholder</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;"> &#39;</span><span style="color:#C3E88D;">xxxx</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>原理</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> cloneElement </span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;"> (</span><span style="color:#BABED8;font-style:italic;">element</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;font-style:italic;"> config</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;"> ...</span><span style="color:#BABED8;font-style:italic;">children</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#C792EA;">  const</span><span style="color:#BABED8;"> props</span><span style="color:#89DDFF;"> =</span><span style="color:#BABED8;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">assign</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{},</span><span style="color:#BABED8;"> element</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">props</span><span style="color:#F07178;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">  let</span><span style="color:#BABED8;"> defaultProps</span><span style="color:#89DDFF;"> =</span><span style="color:#89DDFF;"> {}</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">  if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">element</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">type</span><span style="color:#89DDFF;"> &amp;&amp;</span><span style="color:#BABED8;"> element</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">type</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">defaultProps</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    defaultProps</span><span style="color:#89DDFF;"> =</span><span style="color:#BABED8;"> element</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">type</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">defaultProps</span></span>
<span class="line"><span style="color:#89DDFF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">  for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> propName</span><span style="color:#89DDFF;"> in</span><span style="color:#BABED8;"> config</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">    if</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">propName</span><span style="color:#89DDFF;"> !==</span><span style="color:#89DDFF;"> &quot;</span><span style="color:#C3E88D;">key</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> &amp;&amp;</span><span style="color:#BABED8;"> propName</span><span style="color:#89DDFF;"> !==</span><span style="color:#89DDFF;"> &quot;</span><span style="color:#C3E88D;">ref</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#C792EA;">      let</span><span style="color:#BABED8;"> val</span><span style="color:#89DDFF;"> =</span><span style="color:#BABED8;"> config</span><span style="color:#F07178;">[</span><span style="color:#BABED8;">propName</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">||</span><span style="color:#BABED8;"> defaultProps</span><span style="color:#F07178;">[</span><span style="color:#BABED8;">propName</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#BABED8;">      val</span><span style="color:#89DDFF;"> &amp;&amp;</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">props</span><span style="color:#F07178;">[</span><span style="color:#BABED8;">propName</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> val</span><span style="color:#F07178;"> )</span></span>
<span class="line"><span style="color:#89DDFF;">    }</span></span>
<span class="line"><span style="color:#89DDFF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">  props</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">children</span><span style="color:#89DDFF;"> =</span><span style="color:#BABED8;"> children</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">map</span><span style="color:#F07178;">(</span><span style="color:#BABED8;font-style:italic;">child</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#89DDFF;">    typeof</span><span style="color:#BABED8;"> child</span><span style="color:#89DDFF;"> ==</span><span style="color:#89DDFF;"> &#39;</span><span style="color:#C3E88D;">object</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;"> ?</span><span style="color:#BABED8;"> children</span><span style="color:#89DDFF;"> :</span><span style="color:#82AAFF;"> createTextNode</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">child</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  )</span></span>
<span class="line"><span style="color:#F07178;">    </span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">  return</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#F07178;">    key</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> element</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">key</span><span style="color:#89DDFF;"> ||</span><span style="color:#BABED8;"> config</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">key</span><span style="color:#89DDFF;"> ||</span><span style="color:#89DDFF;"> &#39;&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    type</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> element</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">type</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">    props</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">  }</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div>`,92)]))}const y=a(p,[["render",o]]);export{d as __pageData,y as default};
