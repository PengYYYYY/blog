import{_ as s,c as a,o as n,a as l}from"./app.355e7a82.js";const p='{"title":"模块化","description":"","frontmatter":{},"headers":[{"level":2,"title":"为什么需要模块化","slug":"为什么需要模块化"},{"level":2,"title":"CommonJS规范","slug":"commonjs规范"},{"level":3,"title":"用法","slug":"用法"},{"level":3,"title":"实现","slug":"实现"},{"level":2,"title":"AMD","slug":"amd"},{"level":3,"title":"AMD用法","slug":"amd用法"},{"level":2,"title":"CMD规范","slug":"cmd规范"},{"level":2,"title":"UMD","slug":"umd"},{"level":2,"title":"ES6 module","slug":"es6-module"},{"level":2,"title":"CommonJS，ES module 的区别","slug":"commonjs，es-module-的区别"}],"relativePath":"font-end/engineering/modular.md"}',o={},e=[l('<h1 id="模块化" tabindex="-1">模块化 <a class="header-anchor" href="#模块化" aria-hidden="true">#</a></h1><ul><li>CommonJS规范</li><li>AMD</li><li>CMD</li><li>UMD</li><li>ES6 modules</li></ul><h2 id="为什么需要模块化" tabindex="-1">为什么需要模块化 <a class="header-anchor" href="#为什么需要模块化" aria-hidden="true">#</a></h2><ul><li>污染全局作用域。容易有命名冲突问题</li><li>依赖关系不明显，不利于维护</li><li>开发和后期维护成本较高</li><li>无法做工程化</li></ul><h2 id="commonjs规范" tabindex="-1">CommonJS规范 <a class="header-anchor" href="#commonjs规范" aria-hidden="true">#</a></h2><p>Node.js是commonJS规范的主要应用者</p><p>module、exports、require、global是它的关键字</p><h3 id="用法" tabindex="-1">用法 <a class="header-anchor" href="#用法" aria-hidden="true">#</a></h3><p>通过 require方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口</p><ul><li>a.js</li></ul><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> x </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> add </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">x</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">};</span></span>\n<span class="line"><span style="color:#89DDFF;">module.exports.</span><span style="color:#A6ACCD;">x </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> x</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#89DDFF;">module.exports.</span><span style="color:#A6ACCD;">add </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> add</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"></span></code></pre></div><ul><li>b.js</li></ul><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./a.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(example</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">x)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 5</span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(example</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 6</span></span>\n<span class="line"></span></code></pre></div><h3 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-hidden="true">#</a></h3><p>其实在编译的过程中，Node 对我们定义的 JS 模块进行了一次基础的包装</p><div class="language-js"><pre><code><span class="line"><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">exports</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> require</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> modules</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> __filename</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> __dirname</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">...</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span></code></pre></div><p>这样我们便可以访问这些传入的arguments以及隔离了彼此的作用域。 CommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p><div class="language-js"><pre><code><span class="line"><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">id</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">...</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">exports</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">...</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">},</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">loaded</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">...</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><p>以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。commonJS用同步的方式加载模块，只有在代码执行到require的时候，才回去执行加载。在服务端，模块文件都存在本地磁盘，读取非常快.</p><p>优点：CommonJS规范完成了JavaScript的模块化，解决了依赖、全局变量污染的问题</p><p>缺点：在浏览器端，限于网络原因，更合理的方案是使用异步加载。这就是AMD规范诞生的背景。</p><h2 id="amd" tabindex="-1">AMD <a class="header-anchor" href="#amd" aria-hidden="true">#</a></h2><p>异步加载模块：这里异步指的是不堵塞浏览器其他任务（dom构建，css渲染等），而加载内部是同步的（加载完模块后立即执行回调）</p><h3 id="amd用法" tabindex="-1">AMD用法 <a class="header-anchor" href="#amd用法" aria-hidden="true">#</a></h3><p>define()定义模块，用require()加载模块</p><ul><li>define(id, [depends], callback)</li><li>require([module], callback)</li></ul><div class="language-js"><pre><code><span class="line"></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// 定义 moduleA 依赖 a, b模块</span></span>\n<span class="line"><span style="color:#82AAFF;">define</span><span style="color:#A6ACCD;">([</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./b</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">,</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">b</span><span style="color:#89DDFF;">){</span></span>\n<span class="line"><span style="color:#F07178;">   </span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">doSomething</span><span style="color:#F07178;">()</span></span>\n<span class="line"><span style="color:#F07178;">   </span><span style="color:#A6ACCD;">b</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">doSomething</span><span style="color:#F07178;">()</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">) </span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// 使用</span></span>\n<span class="line"><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">([</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./moduleA</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">moduleA</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span></code></pre></div><p>优点：适合在浏览器环境中异步加载模块。 可以并行加载多个模块。</p><p>缺点：不能按需加载，而是必须提前加载所有的依赖。</p><h2 id="cmd规范" tabindex="-1">CMD规范 <a class="header-anchor" href="#cmd规范" aria-hidden="true">#</a></h2><p>按需加载，依赖就近，延迟执行</p><div class="language-js"><pre><code><span class="line"><span style="color:#82AAFF;">define</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">require</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> exports</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> module</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">require</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//在需要时申明</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">doSomething</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#FF9CAC;">false</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">b</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">require</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./b</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">b</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">doSomething</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span></code></pre></div><p>代码在运行时，首先是不知道依赖的，需要遍历所有的require关键字，找出后面的依赖。具体做法是将function toString后，用正则匹配出require关键字后面的依赖。牺牲性能来换取更多开发便利的方法。</p><p>而 AMD 是依赖前置的，换句话而 AMD 是依赖前置的，在解析和执行当前模块之前，模块作者必须指明当前模块所依赖的模块。代码在一旦运行到此处，能立即知晓依赖。而无需遍历整个函数体找到它的依赖，因此性能有所提升，缺点就是开发者必须显式得指明依赖——这会使得开发工作量变大。</p><h2 id="umd" tabindex="-1">UMD <a class="header-anchor" href="#umd" aria-hidden="true">#</a></h2><p>不是一种规范,是结合 AMD 和 CommonJS 的一种更为通用的 JS 模块解决方案,在webpack打包的时候进行配置</p><h2 id="es6-module" tabindex="-1">ES6 module <a class="header-anchor" href="#es6-module" aria-hidden="true">#</a></h2><p>ES6 Modules不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p><ul><li>之前的几种模块化方案都是前端社区自己实现的，只是得到了大家的认可和广泛使用</li><li>ES6 在语言标准的层面上，实现了模块功能，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li><li>由于ES6目前在部分浏览器无法执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。</li></ul><p>在开发环境中使用众多。</p><p><a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener noreferrer">支持情况</a></p><h2 id="commonjs，es-module-的区别" tabindex="-1">CommonJS，ES module 的区别 <a class="header-anchor" href="#commonjs，es-module-的区别" aria-hidden="true">#</a></h2><p>它们都是一种模块规范，例如 Node 使用的就是 CommonJS 规范。ES module 则是语言标准上的模块规范。</p><ul><li>CommonJS 模块使用 require() 和 module.exports，ES6 模块使用 import和 export。</li><li>CommonJS 模块输出的是一个值的浅拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li><li>CommonJS 模块的 require() 是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段。</li><li>ES6 模块之中，顶层的 this 指向 undefined；CommonJS 模块的顶层 this 指向当前模块，</li><li>对于循环加载的处理方法不同</li></ul><p>第 3 个差异是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。</p>',45)];var r=s(o,[["render",function(s,l,p,o,r,c){return n(),a("div",null,e)}]]);export{p as __pageData,r as default};
