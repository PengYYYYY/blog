import{_ as e,c as s,o as a,a as l}from"./app.a1079f6c.js";const p='{"title":"vite","description":"","frontmatter":{},"headers":[{"level":2,"title":"基本原理","slug":"基本原理"},{"level":2,"title":"modules 模块","slug":"modules-模块"},{"level":2,"title":"拦截 HTTP 请求","slug":"拦截-http-请求"},{"level":2,"title":"Vite 热更新实现","slug":"vite-热更新实现"},{"level":3,"title":"客户端","slug":"客户端"},{"level":3,"title":"服务端","slug":"服务端"}],"relativePath":"font-end/engineering/vite.md"}',n={},o=[l('<h1 id="vite" tabindex="-1">vite <a class="header-anchor" href="#vite" aria-hidden="true">#</a></h1><h2 id="基本原理" tabindex="-1">基本原理 <a class="header-anchor" href="#基本原理" aria-hidden="true">#</a></h2><ul><li>vite主要对应的场景是开发模式，原理是拦截浏览器发出的 ES imports 请求并做相应处理。</li><li>Vite 在开发模式下不需要打包，只需要编译浏览器发出的 HTTP 请求对应的文件即可，所以热更新速度很快。</li></ul><p>需要项目中只使用原生 ES imports，使用了 require 将失效，从本质上来说，Vite 可能更像是替代了 webpack-dev-server 的一个东西。</p><h2 id="modules-模块" tabindex="-1">modules 模块 <a class="header-anchor" href="#modules-模块" aria-hidden="true">#</a></h2><p>这边牵扯到了模块化，cmd,amd,umd,commonjs,esmodule。</p><div class="language-js"><pre><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">import </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> main </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> from &#39;./main.js&#39;</span></span>\n<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"></span></code></pre></div><p>当声明一个 script 标签类型为 module 时，浏览器将对其内部的 import 引用发起 HTTP 请求获取模块内容。比如上述，浏览器将发起一个对 HOST/main.js 的 HTTP 请求，获取到内容之后再执行。</p><p>vite会劫持这个请求，相当于做一层代理，并在后端进行相应的处理，（将 Vue 文件拆分成 template、style、script 三个部分），然后再返回给浏览器。</p><p>由于浏览器会对用到的模块发起 HTTP 请求，所以 Vite 没必要对项目里所有的文件先打包后返回，而是只编译浏览器发起 HTTP 请求的模块即可。相当于按需更新。</p><h2 id="拦截-http-请求" tabindex="-1">拦截 HTTP 请求 <a class="header-anchor" href="#拦截-http-请求" aria-hidden="true">#</a></h2><div class="language-js"><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">createApp</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"></span></code></pre></div><p>替换成</p><div class="language-js"><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">createApp</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/@modules/vue</span></span>\n<span class="line"></span></code></pre></div><p><code>Vite</code> 在拦截的请求里，对直接引用 <code>node_modules</code> 的模块都做了路径的替换，换成了 <code>/@modules/</code> 并返回回去。而后浏览器收到后，会发起对 <code>/@modules/xxx</code> 的请求，然后被 <code>Vite</code> 再次拦截，并由 <code>Vite</code> 内部去访问真正的模块，并将得到的内容再次做同样的处理后，返回给浏览器。</p><p>对于<code>@modules/* 路径解析</code>,核心逻辑就是<code>node_modules</code>里找有没有对应的模块，有的话就返回，没有的话就报 404。</p><h2 id="vite-热更新实现" tabindex="-1">Vite 热更新实现 <a class="header-anchor" href="#vite-热更新实现" aria-hidden="true">#</a></h2><p>vite通过 <code>WebSocket</code> 来实现的热更新通信。</p><h3 id="客户端" tabindex="-1">客户端 <a class="header-anchor" href="#客户端" aria-hidden="true">#</a></h3><p>Vite 的 WS 客户端目前监听这几种消息：</p><ul><li>connected: WebSocket 连接成功</li><li>vue-reload: Vue 组件重新加载（当你修改了 script 里的内容时）</li><li>vue-rerender: Vue 组件重新渲染（当你修改了 template 里的内容时）</li><li>style-update: 样式更新</li><li>style-remove: 样式移除</li><li>js-update: js 文件更新</li><li>full-reload: fallback 机制，网页重刷新</li></ul><p>其中针对 Vue 组件本身的一些更新，都可以直接调用 HMRRuntime 提供的方法，非常方便。其余的更新逻辑，基本上都是利用了 timestamp 刷新缓存重新执行的方法来达到更新的目的。</p><h3 id="服务端" tabindex="-1">服务端 <a class="header-anchor" href="#服务端" aria-hidden="true">#</a></h3><p>核心是监听项目文件的变更，然后根据不同文件类型（目前只有 vue 和 js）来做不同的处理：</p><p>对于 vue 文件的热更新而言，主要是重新编译 Vue 文件，检测 template 、script 、style 的改动，如果有改动就通过 WS 服务端发起对应的热更新请求。</p><p>对于热更新 js 文件而言，会递归地查找引用这个文件的 importer。比如是某个 Vue 文件所引用了这个 js，就会被查找出来。假如最终发现找不到引用者，则会返回 hasDeadEnd: true。</p>',26)];var t=e(n,[["render",function(e,l,p,n,t,r){return a(),s("div",null,o)}]]);export{p as __pageData,t as default};
