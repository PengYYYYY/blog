import{_ as e,o as s,c as o,a}from"./app.b2186ba6.js";const D=JSON.parse('{"title":"vite","description":"","frontmatter":{},"headers":[{"level":2,"title":"基本原理","slug":"基本原理","link":"#基本原理","children":[]},{"level":2,"title":"modules 模块","slug":"modules-模块","link":"#modules-模块","children":[]},{"level":2,"title":"拦截 HTTP 请求","slug":"拦截-http-请求","link":"#拦截-http-请求","children":[]},{"level":2,"title":"vite 启动","slug":"vite-启动","link":"#vite-启动","children":[]},{"level":2,"title":"vite 热更新","slug":"vite-热更新","link":"#vite-热更新","children":[{"level":3,"title":"客户端","slug":"客户端","link":"#客户端","children":[]},{"level":3,"title":"服务端","slug":"服务端","link":"#服务端","children":[]}]}],"relativePath":"font-end/engineering/vite.md","lastUpdated":1672673639000}'),l={name:"font-end/engineering/vite.md"},c=a(`<h1 id="vite" tabindex="-1">vite <a class="header-anchor" href="#vite" aria-hidden="true">#</a></h1><h2 id="基本原理" tabindex="-1">基本原理 <a class="header-anchor" href="#基本原理" aria-hidden="true">#</a></h2><ul><li><code>vite</code> 主要对应的场景是开发模式，原理是拦截浏览器发出的 <code>ES imports</code> 请求并做相应处理。</li><li><code>vite</code> 在开发模式下不需要打包，只需要编译浏览器发出的 <code>HTTP</code> 请求对应的文件即可，所以热更新速度很快。</li></ul><p>需要项目中只使用原生 <code>ES imports</code>，使用了 <code>require</code> 将失效，从本质上来说，<code>vite</code> 可能更像是替代了 <code>webpack-dev-server</code> 的一个东西，生产环境中使用 <code>rollup</code> 进行打包。</p><h2 id="modules-模块" tabindex="-1">modules 模块 <a class="header-anchor" href="#modules-模块" aria-hidden="true">#</a></h2><p>这边牵扯到了模块化，<code>cmd</code>, <code>amd</code>, <code>umd</code>, <code>commonjs</code>, <code>es module</code> 。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">import </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> main </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> from &#39;./main.js&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当声明一个 <code>script</code> 标签类型为 <code>module</code> 时，浏览器将对其内部的 <code>import</code> 引用发起 <code>HTTP</code> 请求获取模块内容。比如上述，浏览器将发起一个对 <code>HOST/main.js</code> 的 <code>HTTP</code> 请求，获取到内容之后再执行。</p><p><code>vite</code> 会劫持这个请求，相当于做一层代理，并在后端进行相应的处理，（将 <code>Vue</code> 文件拆分成 <code>template、style、script</code> 三个部分），然后再返回给浏览器。</p><p>由于浏览器会对用到的模块发起 <code>HTTP</code> 请求，所以 <code>Vite</code> 没必要对项目里所有的文件先打包后返回，而是只编译浏览器发起 <code>HTTP</code> 请求的模块即可。相当于按需更新。</p><h2 id="拦截-http-请求" tabindex="-1">拦截 HTTP 请求 <a class="header-anchor" href="#拦截-http-请求" aria-hidden="true">#</a></h2><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">createApp</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>替换成</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">createApp</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/@modules/vue</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>Vite</code> 在拦截的请求里，对直接引用 <code>node_modules</code> 的模块都做了路径的替换，换成了 <code>/@modules/</code> 并返回回去。而后浏览器收到后，会发起对 <code>/@modules/xxx</code> 的请求，然后被 <code>Vite</code> 再次拦截，并由 <code>Vite</code> 内部去访问真正的模块，并将得到的内容再次做同样的处理后，返回给浏览器。</p><p>对于<code>@modules/* 路径解析</code>,核心逻辑就是<code>node_modules</code>里找有没有对应的模块，有的话就返回，没有的话就报 404。</p><h2 id="vite-启动" tabindex="-1">vite 启动 <a class="header-anchor" href="#vite-启动" aria-hidden="true">#</a></h2><p><code>vite</code> 启动会利用 <code>esbuild</code> 将依赖包进行打包，导出 <code>es</code> 模块, 运行 <code>vite --force</code> 时会重新编译依赖，启动过程中需要一点时间，但是不会很长，在后续的热更新过程中非常快。</p><p><code>[vite] ✨ new dependencies optimized: prismjs, prismjs/components/prism-bash.js</code></p><h2 id="vite-热更新" tabindex="-1">vite 热更新 <a class="header-anchor" href="#vite-热更新" aria-hidden="true">#</a></h2><p>vite通过 <code>WebSocket</code> 来实现的热更新通信。</p><h3 id="客户端" tabindex="-1">客户端 <a class="header-anchor" href="#客户端" aria-hidden="true">#</a></h3><p>Vite 的 WS 客户端目前监听这几种消息：</p><ul><li>connected: <code>WebSocket</code> 连接成功</li><li>vue-reload: <code>Vue</code> 组件重新加载（当你修改了 <code>script</code> 里的内容时）</li><li>vue-rerender: <code>Vue</code> 组件重新渲染（当你修改了 <code>template</code> 里的内容时）</li><li>style-update: 样式更新</li><li>style-remove: 样式移除</li><li>js-update: js 文件更新</li><li>full-reload: <code>fallback</code> 机制，网页重刷新</li></ul><p>其中针对 Vue 组件本身的一些更新，都可以直接调用 HMRRuntime 提供的方法，非常方便。其余的更新逻辑，基本上都是利用了 timestamp 刷新缓存重新执行的方法来达到更新的目的。</p><h3 id="服务端" tabindex="-1">服务端 <a class="header-anchor" href="#服务端" aria-hidden="true">#</a></h3><p>核心是监听项目文件的变更，然后根据不同文件类型（目前只有 <code>vue</code> 和 <code>js</code>）来做不同的处理：</p><p>对于 <code>vue</code> 文件的热更新而言，主要是重新编译 Vue 文件，检测 <code>template</code> <code>、script</code> <code>、style</code> 的改动，如果有改动就通过 <code>WS</code> 服务端发起对应的热更新请求。</p><p>对于热更新 <code>js</code> 文件而言，会递归地查找引用这个文件的 <code>importer</code>。比如是某个 <code>Vue</code> 文件所引用了这个 <code>js</code>，就会被查找出来。假如最终发现找不到引用者，则会返回 <code>hasDeadEnd: true</code>。</p>`,29),n=[c];function d(t,p,i,r,u,h){return s(),o("div",null,n)}const v=e(l,[["render",d]]);export{D as __pageData,v as default};
