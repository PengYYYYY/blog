import{F as n}from"./chunks/FigmaContainer.WcU7yNrP.js";import{c as e,R as a,G as l,o}from"./chunks/framework.3D9yNSa1.js";const p="/blog/assets/EventLoop-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.CSO8ils6.png",t="/blog/assets/EventLoop-%E5%8D%95%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%97%B6%E9%95%BF.CS51bsey.png",c="/blog/assets/EventLoop-Node.CCX3DAmS.jpg",y=JSON.parse('{"title":"JavaScript 中的事件循环","description":"","frontmatter":{},"headers":[],"relativePath":"font-end/js/event-loop.md","filePath":"font-end/js/event-loop.md","lastUpdated":1725463910000}'),r={name:"font-end/js/event-loop.md"},m=Object.assign(r,{setup(i){return(F,s)=>(o(),e("div",null,[s[0]||(s[0]=a('<h1 id="javascript-中的事件循环" tabindex="-1">JavaScript 中的事件循环 <a class="header-anchor" href="#javascript-中的事件循环" aria-label="Permalink to &quot;JavaScript 中的事件循环&quot;">​</a></h1><p><code>JavaScript</code> 中的事件循环机制</p><h2 id="进程与线程" tabindex="-1">进程与线程 <a class="header-anchor" href="#进程与线程" aria-label="Permalink to &quot;进程与线程&quot;">​</a></h2><p><code>JS</code> 是单线程执行的，讲到线程，那么也得说一下进程，本质上来说，两个名词都是 <code>CPU</code> 工作时间片的一个描述。</p><p>进程描述了 <code>CPU</code> 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间。</p><p>当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等，当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p><h2 id="为什么有事件循环" tabindex="-1">为什么有事件循环 <a class="header-anchor" href="#为什么有事件循环" aria-label="Permalink to &quot;为什么有事件循环&quot;">​</a></h2><p>因为每一个渲染进程都只有一个主线程，并且主线程非常忙，要处理 Dom,又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。所以会有各种类型的任务在主线程中有条不紊地执行，所以需要一个事件循环系统来统一的调度这些任务。通过消息队列进行消息收集。</p><h3 id="线程模型" tabindex="-1">线程模型 <a class="header-anchor" href="#线程模型" aria-label="Permalink to &quot;线程模型&quot;">​</a></h3><p><img src="'+p+`" alt="img"></p><ol><li>添加一个消息队列;</li><li>IO 线程中产生的新任务添加进消息队列尾部;</li><li>渲染主线程会循环地从消息队列头部中读取任务，执行任务</li></ol><p>简单的代码实现</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#C792EA;">  constructor</span><span style="color:#89DDFF;">()</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#89DDFF;">    this.</span><span style="color:#BABED8;">queue</span><span style="color:#89DDFF;"> =</span><span style="color:#F07178;"> []</span></span>
<span class="line"><span style="color:#89DDFF;">  }</span></span>
<span class="line"><span style="color:#F07178;">  init</span><span style="color:#89DDFF;">()</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">    while</span><span style="color:#F07178;">(</span><span style="color:#FF9CAC;">true</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">      while</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">length</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#C792EA;">        const</span><span style="color:#BABED8;"> task</span><span style="color:#89DDFF;"> =</span><span style="color:#89DDFF;"> this.</span><span style="color:#BABED8;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pop</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">        if</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">typeof</span><span style="color:#BABED8;"> task</span><span style="color:#89DDFF;"> ==</span><span style="color:#89DDFF;"> &#39;</span><span style="color:#C3E88D;">function</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#82AAFF;">          task</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#89DDFF;">        }</span></span>
<span class="line"><span style="color:#89DDFF;">      }</span></span>
<span class="line"><span style="color:#89DDFF;">    }</span></span>
<span class="line"><span style="color:#89DDFF;">  }</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="消息队列中的任务类型" tabindex="-1">消息队列中的任务类型 <a class="header-anchor" href="#消息队列中的任务类型" aria-label="Permalink to &quot;消息队列中的任务类型&quot;">​</a></h3><p>如: 输入事件(鼠标滚动、点击、移动)、微任务、文件读写、WebSocket、JavaScript 定时器等等。</p><p>除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。</p><p>以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。</p><h3 id="任务优先级问题" tabindex="-1">任务优先级问题 <a class="header-anchor" href="#任务优先级问题" aria-label="Permalink to &quot;任务优先级问题&quot;">​</a></h3><p>事件有分主次先后，通过区分宏任务和微任务来保证执行效率。</p><p>我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。</p><p>宏任务中的主要功能都直接完成之后，这时候渲染引擎并不着急去执行下一个宏任务， 而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。</p><h3 id="解决单个任务执行时长过久的问题" tabindex="-1">解决单个任务执行时长过久的问题 <a class="header-anchor" href="#解决单个任务执行时长过久的问题" aria-label="Permalink to &quot;解决单个任务执行时长过久的问题&quot;">​</a></h3><p>因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。</p><p><img src="`+t+'" alt="img"></p><h2 id="浏览器中的-event-loop" tabindex="-1">浏览器中的 Event Loop <a class="header-anchor" href="#浏览器中的-event-loop" aria-label="Permalink to &quot;浏览器中的 Event Loop&quot;">​</a></h2>',25)),l(n,{url:"https://www.figma.com/file/E2utI9rEseFTc7tJ3Bbl9o/blog?type=whiteboard&node-id=6430-2562&t=mB5ZHa6vGkN4Sukx-4"}),s[1]||(s[1]=a('<p>Event Loop 执行顺序:</p><ol><li>首先执行同步代码，这属于宏任务</li><li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li><li>执行所有微任务</li><li>当执行完所有微任务后，如有必要会渲染页面</li><li>然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数</li></ol><p>微任务包括: <code>process.nextTick</code>，<code>promise</code> ，<code>MutationObserver</code>，其中 <code>process.nextTick</code> 为 <code>Node</code> 独有。</p><p>宏任务包括 <code>script</code>,<code>setTimeout</code>, <code>setInterval</code>,<code>setImmediate</code>,<code>I/O</code>,<code>UI rendering</code>。</p><h2 id="node-中的-event-loop" tabindex="-1">Node 中的 Event Loop <a class="header-anchor" href="#node-中的-event-loop" aria-label="Permalink to &quot;Node 中的 Event Loop&quot;">​</a></h2><blockquote><p>node.js 运行流程</p></blockquote><p><img src="'+c+'" alt="img"></p><p>Node.js 的运行机制如下:</p><ul><li>V8 引擎解析 JavaScript 脚本。</li><li>解析后的代码，调用 Node API。</li><li>LibUV 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。</li><li>V8 引擎再将结果返回给用户。</li></ul><blockquote><p>六个阶段</p></blockquote>',10)),l(n,{url:"https://www.figma.com/file/E2utI9rEseFTc7tJ3Bbl9o/blog?type=whiteboard&node-id=6430-2289&t=mB5ZHa6vGkN4Sukx-4"}),s[2]||(s[2]=a(`<p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。 Node 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量达到系统的阀值，就会进入下一个阶段。</p><h3 id="timer" tabindex="-1">timer <a class="header-anchor" href="#timer" aria-label="Permalink to &quot;timer&quot;">​</a></h3><p><code>timers</code> 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code> 的回调，并且是由 poll 阶段控制的。 所以在node中的定时器指定的时间也不是准确时间，只能是尽快执行。</p><h3 id="i-o-callback阶段" tabindex="-1">I/O，callback阶段 <a class="header-anchor" href="#i-o-callback阶段" aria-label="Permalink to &quot;I/O，callback阶段&quot;">​</a></h3><p>执行除了 <code>close</code> 事件的 <code>callbacks</code>、被 <code>timers</code> 设定的 <code>callbacks</code>, <code>setImmediate()</code> 设定的 <code>callbacks</code> 这些之外的 <code>callbacks</code>，<code>I/O</code> 阶段会执行上一轮循环中少数未执行的 <code>I/O</code> 回调.</p><h3 id="idl-prepare" tabindex="-1">idl，prepare <a class="header-anchor" href="#idl-prepare" aria-label="Permalink to &quot;idl，prepare&quot;">​</a></h3><p>仅供 <code>node</code> 内部使用.</p><h3 id="poll" tabindex="-1">poll <a class="header-anchor" href="#poll" aria-label="Permalink to &quot;poll&quot;">​</a></h3><p>这一阶段中，系统会做两件事情</p><ol><li>回到 <code>timer</code> 阶段执行回调</li><li>执行 <code>I/O</code> 回调</li></ol><ul><li>如果 <code>poll</code> 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li><li>如果 <code>poll</code> 队列为空时，会有两件事发生 <ul><li>如果有 <code>setImmediate</code> 回调需要执行，<code>poll</code> 阶段会停止并且进入到 check 阶段执行回调</li><li>如果没有 <code>setImmediate</code> 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li></ul></li></ul><p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p><h3 id="check" tabindex="-1">check <a class="header-anchor" href="#check" aria-label="Permalink to &quot;check&quot;">​</a></h3><p><code>check</code> 阶段执行 <code>setImmediate</code></p><h3 id="close-callbacks" tabindex="-1">close callbacks <a class="header-anchor" href="#close-callbacks" aria-label="Permalink to &quot;close callbacks&quot;">​</a></h3><p>执行 socket.on(&#39;close&#39;, ....) 这些 callbacks</p><h3 id="nodejs-中宏队列主要有4个" tabindex="-1">NodeJS 中宏队列主要有4个 <a class="header-anchor" href="#nodejs-中宏队列主要有4个" aria-label="Permalink to &quot;NodeJS 中宏队列主要有4个&quot;">​</a></h3><p>由上面的介绍可以看到，回调事件主要位于4个 <code>macrotask queue</code> 中：</p><ol><li>Timers Queue</li><li>IO Callbacks Queue</li><li>Check Queue</li><li>Close Callbacks Queue</li></ol><p>不同类型的 <code>macrotask queue</code> 会被放入不同的宏任务队列中。在浏览器中</p><p>NodeJs 的微任务队列主要有2个：</p><p><code>Next Tick Queue</code>：是放置process.nextTick(callback)的回调任务的 <code>Other Micro Queue</code>：放置其他microtask，比如Promise等</p><h3 id="版本差异" tabindex="-1">版本差异 <a class="header-anchor" href="#版本差异" aria-label="Permalink to &quot;版本差异&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">timer1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#FFCB6B;">  Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#BABED8;">    console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">promise1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">  }</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#F78C6C;"> 0</span><span style="color:#BABED8;">)</span></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">timer2</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#FFCB6B;">  Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#BABED8;">    console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">promise2</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">  }</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#F78C6C;"> 0</span><span style="color:#BABED8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="timers-阶段的执行时机变化" tabindex="-1">timers 阶段的执行时机变化 <a class="header-anchor" href="#timers-阶段的执行时机变化" aria-label="Permalink to &quot;timers 阶段的执行时机变化&quot;">​</a></h4><blockquote><p>node11</p></blockquote><p>如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为timer1=&gt;promise1=&gt;timer2=&gt;promise2</p><blockquote><p>node10</p></blockquote><p>如果是 node10 及其之前版本要看第一个定时器执行完，第二个定时器是否在完成队列中.</p><ul><li>如果是第二个定时器还未在完成队列中，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li><li>如果是第二个定时器已经在完成队列中，则最后的结果为<code>timer1=&gt;timer2=&gt;promise1=&gt;promise2</code></li></ul><h4 id="check-阶段的执行时机变化" tabindex="-1">check 阶段的执行时机变化 <a class="header-anchor" href="#check-阶段的执行时机变化" aria-label="Permalink to &quot;check 阶段的执行时机变化&quot;">​</a></h4><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#82AAFF;">setImmediate</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#BABED8;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">immediate1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">setImmediate</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#BABED8;">    console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">immediate2</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#FFCB6B;">    Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#BABED8;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">promise resolve</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">))</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">setImmediate</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#BABED8;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">immediate3</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">setImmediate</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#BABED8;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">immediate4</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">))</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>如果是 node11 后的版本，会输<code>immediate1=&gt;immediate2=&gt;promise resolve=&gt;immediate3=&gt;immediate4</code></li><li>如果是 node11 前的版本，会输<code>出immediate1=&gt;immediate2=&gt;immediate3=&gt;immediate4=&gt;promise resolve</code></li></ul><h4 id="nexttick-队列的执行时机变化" tabindex="-1">nextTick 队列的执行时机变化 <a class="header-anchor" href="#nexttick-队列的执行时机变化" aria-label="Permalink to &quot;nextTick 队列的执行时机变化&quot;">​</a></h4><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#82AAFF;">setImmediate</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#BABED8;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">timeout1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">setImmediate</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#BABED8;">    console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">timeout2</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#BABED8;">    process</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">nextTick</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#BABED8;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">next tick</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">))</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">setImmediate</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#BABED8;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">timeout3</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">setImmediate</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#BABED8;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">timeout4</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">))</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>如果是 node11 后的版本，会输出timeout1=&gt;timeout2=&gt;next tick=&gt;timeout3=&gt;timeout4</li><li>如果是 node11 前的版本，会输出timeout1=&gt;timeout2=&gt;timeout3=&gt;timeout4=&gt;next tick</li></ul><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><p>如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行对应的微任务队列。</p><p><a href="https://juejin.cn/post/6844904079353708557#heading-4" target="_blank" rel="noreferrer">掘金参考文章</a></p>`,39))]))}});export{y as __pageData,m as default};
