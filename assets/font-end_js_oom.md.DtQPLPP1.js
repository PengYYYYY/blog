import{_ as a,c as e,o as t,U as i}from"./chunks/framework.B9byA8Cw.js";const o="/blog/assets/zhu7Hi.B2u3v4ox.png",r="/blog/assets/QN2SMk.AOEUCbtA.png",s="/blog/assets/DLWGqs.DGsFCrAk.png",l="/blog/assets/krrmuu.Bsd16iIk.png",S=JSON.parse('{"title":"JavaScript 中的应用内存分析","description":"","frontmatter":{},"headers":[],"relativePath":"font-end/js/oom.md","filePath":"font-end/js/oom.md","lastUpdated":1710086962000}'),c={name:"font-end/js/oom.md"},n=i('<h1 id="javascript-中的应用内存分析" tabindex="-1">JavaScript 中的应用内存分析 <a class="header-anchor" href="#javascript-中的应用内存分析" aria-label="Permalink to &quot;JavaScript 中的应用内存分析&quot;">​</a></h1><h2 id="内存模型" tabindex="-1">内存模型 <a class="header-anchor" href="#内存模型" aria-label="Permalink to &quot;内存模型&quot;">​</a></h2><p>JavaScript 的内存模型，其主要由堆、栈、队列三方面组成：</p><p><img src="'+o+'" alt="img"></p><ul><li>队列指的是消息队列</li><li>栈就是函数执行栈</li></ul><p><img src="'+r+'" alt="img"></p><h2 id="垃圾回收" tabindex="-1"><a href="./scope-gc.html#垃圾回收">垃圾回收</a> <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to &quot;[垃圾回收](./scope-gc.html#垃圾回收)&quot;">​</a></h2><h2 id="内存泄漏" tabindex="-1">内存泄漏 <a class="header-anchor" href="#内存泄漏" aria-label="Permalink to &quot;内存泄漏&quot;">​</a></h2><p>所谓的内存泄漏，即是指某个对象被无意间添加了某条引用，导致虽然实际上并不需要了，但还是能一直被遍历可达，以致其内存始终无法回收。本部分我们简要讨论下 JavaScript 中常见的内存泄漏情境与处理方法。在新版本的 Chrome 中我们可以使用 Performance Monitor 来动态监测网页性能的变化：</p><p><img src="'+s+'" alt="img"></p><ul><li>JS heap size - 应用的内存占用量；</li><li>DOM Nodes - 内存中 DOM 节点数目；</li><li>Documents - 当前页面中使用的样式或者脚本文件数目；</li><li>listeners- 当前页面上注册的 JavaScript 时间监听器数目;</li><li>GPU usage - 当前站点的 GPU 使用量；</li></ul><h3 id="memory" tabindex="-1">memory <a class="header-anchor" href="#memory" aria-label="Permalink to &quot;memory&quot;">​</a></h3><p><img src="'+l+'" alt="img"></p><p>通过memory可以看到整体的内存情况，有以下几种：</p><ul><li>全局变量</li><li>定时器与闭包</li><li>DOM 引用与监听器</li><li>iframe</li><li>Web Worker</li></ul>',15),m=[n];function p(h,d,_,u,g,f){return t(),e("div",null,m)}const k=a(c,[["render",p]]);export{S as __pageData,k as default};
