import{_ as a,c as e,o as t,U as i}from"./chunks/framework.B9byA8Cw.js";const m=JSON.parse('{"title":"性能指标","description":"","frontmatter":{},"headers":[],"relativePath":"font-end/optimize/indicators.md","filePath":"font-end/optimize/indicators.md","lastUpdated":1710086962000}'),n={name:"font-end/optimize/indicators.md"},o=i('<h1 id="性能指标" tabindex="-1">性能指标 <a class="header-anchor" href="#性能指标" aria-label="Permalink to &quot;性能指标&quot;">​</a></h1><p>指标分为三类：文档加载相关、内容呈现相关、交互响应性相关，并基于这些指标提取出与用户最相关的核心指标。</p><h2 id="文档加载相关" tabindex="-1">文档加载相关 <a class="header-anchor" href="#文档加载相关" aria-label="Permalink to &quot;文档加载相关&quot;">​</a></h2><p>文档加载过程时间线如图，这里主要介绍三个指标：TTFB、DCL 和 Load 时间。</p><h3 id="time-to-first-byte" tabindex="-1">Time to first Byte <a class="header-anchor" href="#time-to-first-byte" aria-label="Permalink to &quot;Time to first Byte&quot;">​</a></h3><p>浏览器从请求页面开始到接收第一字节的时间，这个时间段内包括 DNS 查找、TCP 连接和 SSL 连接。</p><h3 id="documentcontentload" tabindex="-1">DocumentContentLoad <a class="header-anchor" href="#documentcontentload" aria-label="Permalink to &quot;DocumentContentLoad&quot;">​</a></h3><p>DomContentLoaded 事件触发的时间。当 <strong>HTML 文档被完全加载和解析完成之后，DOMContentLoaded</strong>事件被触发，而无需等待样式表、图像和子框架加载完成。</p><h3 id="onload" tabindex="-1">onLoad <a class="header-anchor" href="#onload" aria-label="Permalink to &quot;onLoad&quot;">​</a></h3><p>onLoad 事件触发的时间。页面所有资源都加载完毕后（比如图片，CSS），onLoad 事件才被触发。</p><p>两者具体细节：</p><ul><li><a href="./../html/load.html">Load与DOMContentLoaded</a></li></ul><h2 id="内容呈现相关" tabindex="-1">内容呈现相关 <a class="header-anchor" href="#内容呈现相关" aria-label="Permalink to &quot;内容呈现相关&quot;">​</a></h2><h3 id="first-paint" tabindex="-1">First Paint <a class="header-anchor" href="#first-paint" aria-label="Permalink to &quot;First Paint&quot;">​</a></h3><p>从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。但此变化可能是简单的背景色更新或不引人注意的内容，它并不表示页面内容完整性，可能会报告没有任何可见的内容被绘制的时间。</p><h3 id="first-contentful-paint-fcp" tabindex="-1">First Contentful Paint（FCP） <a class="header-anchor" href="#first-contentful-paint-fcp" aria-label="Permalink to &quot;First Contentful Paint（FCP）&quot;">​</a></h3><ul><li>定义</li></ul><p>浏览器首次绘制来自 DOM 的内容的时间，内容必须是文本、图片（包含背景图）、非白色的 canvas 或 SVG，也包括带有正在加载中的 Web 字体的文本。</p><h3 id="largest-contentful-paint-lcp" tabindex="-1">Largest Contentful Paint（LCP） <a class="header-anchor" href="#largest-contentful-paint-lcp" aria-label="Permalink to &quot;Largest Contentful Paint（LCP）&quot;">​</a></h3><p>可视区域中最大的内容元素呈现到屏幕上的时间，用以估算页面的主要内容对用户可见时间。</p><h3 id="first-screen-paint" tabindex="-1">First Screen Paint <a class="header-anchor" href="#first-screen-paint" aria-label="Permalink to &quot;First Screen Paint&quot;">​</a></h3><p>页面从开始加载到首屏内容全部绘制完成的时间，用户可以看到首屏的全部内容。</p><p>如果说 LCP 是用户看到有效内容的最近似的时间，那么在 FSP 这个时间点用户已经看到了可视区域内完整的内容，可以说是衡量用户视觉体验最合适的指标。</p><h3 id="speed-index" tabindex="-1">Speed Index <a class="header-anchor" href="#speed-index" aria-label="Permalink to &quot;Speed Index&quot;">​</a></h3><p>这是一个表示页面可视区域中内容的填充速度的指标，可以通过计算页面可见区域内容显示的平均时间来衡量。</p><h2 id="交互响应性相关" tabindex="-1">交互响应性相关 <a class="header-anchor" href="#交互响应性相关" aria-label="Permalink to &quot;交互响应性相关&quot;">​</a></h2><h3 id="time-to-interactive" tabindex="-1">Time to Interactive <a class="header-anchor" href="#time-to-interactive" aria-label="Permalink to &quot;Time to Interactive&quot;">​</a></h3><p>表示网页第一次 完全达到可交互状态 的时间点，浏览器已经可以持续性的响应用户的输入。完全达到可交互状态的时间点是在最后一个长任务（Long Task）完成的时间, 并且在随后的 5 秒内网络和主线程是空闲的。</p><p>从定义上来看，中文名称叫可持续交互时间或可流畅交互时间更合适。</p><h3 id="first-cpu-idle-fci" tabindex="-1">First CPU Idle（FCI） <a class="header-anchor" href="#first-cpu-idle-fci" aria-label="Permalink to &quot;First CPU Idle（FCI）&quot;">​</a></h3><p>页面第一次可以响应用户输入的时间。</p><p>FCI 和 TTI 都是页面可以响应用户输入的时间。FCI 发生在用户可以开始与页面交互时；TTI 发生在 用户完全能够（可持续） 与页面交互时。</p><h3 id="first-input-delay-fid" tabindex="-1">First Input Delay（FID） <a class="header-anchor" href="#first-input-delay-fid" aria-label="Permalink to &quot;First Input Delay（FID）&quot;">​</a></h3><p>从用户第一次与页面交互（例如单击链接、点击按钮等）到浏览器实际能够响应该交互的时间。</p><h3 id="frames-per-second-fps" tabindex="-1">Frames Per Second（FPS） <a class="header-anchor" href="#frames-per-second-fps" aria-label="Permalink to &quot;Frames Per Second（FPS）&quot;">​</a></h3><p>帧率是视频设备产生图像（或帧）的速率，用每秒可以重新绘制的帧数（Frames Per Second，FPS）表示。</p><p>重新绘制可能需要重新计算样式、布局和绘制，如果每帧绘制到屏幕的时间在 16.7 ms 以上，每秒绘制的帧数就会小于 60 帧，人眼就能感受到页面出现卡顿，所以 FPS 是衡量应用流畅度的一个非常重要的指标，60fps 是页面流畅的目标，可以为每次绘制提供 16.7ms 的时间预算。</p><ul><li>哪些情况下会触发重新绘制？</li></ul><p>FPS 在电影和游戏中最为常见，但现在被广泛用作衡量网站和网络应用程序性能的指标。</p><p>在 Web 性能中，FPS 最常用于衡量动画的性能：如果 FPS 太低，动画会卡顿。</p><p>FPS 也可以作为用户与页面交互时页面响应性的一般度量。例如，如果将鼠标移到某个页面元素上会触发执行 JavaScript 来更新页面，这可能会触发回流和重绘，这需要在帧中完成，如果浏览器处理帧的时间过长，将会出现卡顿现象。</p><p>再例如，如果在滚动页面时会触发很多复杂的页面更新，并且浏览器无法保持可接受的帧率，那么滚动页面时会显得迟缓或卡顿。</p><ul><li>如何降低重新绘制的时间？</li></ul><p>重新绘制到屏幕可能需要从构建 DOM 树开始、重新计算样式、布局、绘制等，我们需要尽可能的避免触发这些流程，例如使用 CSS 修改 opacity 属性就不会触发重新布局，可以减少绘制时间。</p><p>所以在实现动画时，建议使用性能成本低的 CSS 属性，而不要使用 JavaScript 设置元素</p>',45),r=[o];function l(d,s,p,c,h,u){return t(),e("div",null,r)}const P=a(n,[["render",l]]);export{m as __pageData,P as default};
