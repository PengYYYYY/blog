(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{461:function(t,s,e){"use strict";e.r(s);var a=e(25),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"vite"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vite"}},[t._v("#")]),t._v(" vite")]),t._v(" "),e("h2",{attrs:{id:"基本原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本原理"}},[t._v("#")]),t._v(" 基本原理")]),t._v(" "),e("ul",[e("li",[t._v("vite主要对应的场景是开发模式，原理是拦截浏览器发出的 ES imports 请求并做相应处理。")]),t._v(" "),e("li",[t._v("Vite 在开发模式下不需要打包，只需要编译浏览器发出的 HTTP 请求对应的文件即可，所以热更新速度很快。")])]),t._v(" "),e("p",[t._v("需要项目中只使用原生 ES imports，使用了 require 将失效，从本质上来说，Vite 可能更像是替代了 webpack-dev-server 的一个东西。")]),t._v(" "),e("h2",{attrs:{id:"modules-模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#modules-模块"}},[t._v("#")]),t._v(" modules 模块")]),t._v(" "),e("p",[t._v("这边牵扯到了模块化，cmd,amd,umd,commonjs,esmodule。")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("script type"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"module"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" main "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./main.js'")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("script"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("p",[t._v("当声明一个 script 标签类型为 module 时，浏览器将对其内部的 import 引用发起 HTTP 请求获取模块内容。比如上述，浏览器将发起一个对 HOST/main.js 的 HTTP 请求，获取到内容之后再执行。")]),t._v(" "),e("p",[t._v("vite会劫持这个请求，相当于做一层代理，并在后端进行相应的处理，（将 Vue 文件拆分成 template、style、script 三个部分），然后再返回给浏览器。")]),t._v(" "),e("p",[t._v("由于浏览器会对用到的模块发起 HTTP 请求，所以 Vite 没必要对项目里所有的文件先打包后返回，而是只编译浏览器发起 HTTP 请求的模块即可。相当于按需更新。")]),t._v(" "),e("h2",{attrs:{id:"拦截-http-请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#拦截-http-请求"}},[t._v("#")]),t._v(" 拦截 HTTP 请求")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" createApp "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'vue'")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("替换成")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" createApp "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" '"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("@modules"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("vue\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[e("code",[t._v("Vite")]),t._v(" 在拦截的请求里，对直接引用 "),e("code",[t._v("node_modules")]),t._v(" 的模块都做了路径的替换，换成了 "),e("code",[t._v("/@modules/")]),t._v(" 并返回回去。而后浏览器收到后，会发起对 "),e("code",[t._v("/@modules/xxx")]),t._v(" 的请求，然后被 "),e("code",[t._v("Vite")]),t._v(" 再次拦截，并由 "),e("code",[t._v("Vite")]),t._v(" 内部去访问真正的模块，并将得到的内容再次做同样的处理后，返回给浏览器。")]),t._v(" "),e("p",[t._v("对于"),e("code",[t._v("@modules/* 路径解析")]),t._v(",核心逻辑就是"),e("code",[t._v("node_modules")]),t._v("里找有没有对应的模块，有的话就返回，没有的话就报 404。")]),t._v(" "),e("h2",{attrs:{id:"vite-热更新实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vite-热更新实现"}},[t._v("#")]),t._v(" Vite 热更新实现")]),t._v(" "),e("p",[t._v("vite通过 "),e("code",[t._v("WebSocket")]),t._v(" 来实现的热更新通信。")]),t._v(" "),e("h3",{attrs:{id:"客户端"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#客户端"}},[t._v("#")]),t._v(" 客户端")]),t._v(" "),e("p",[t._v("Vite 的 WS 客户端目前监听这几种消息：")]),t._v(" "),e("ul",[e("li",[t._v("connected: WebSocket 连接成功")]),t._v(" "),e("li",[t._v("vue-reload: Vue 组件重新加载（当你修改了 script 里的内容时）")]),t._v(" "),e("li",[t._v("vue-rerender: Vue 组件重新渲染（当你修改了 template 里的内容时）")]),t._v(" "),e("li",[t._v("style-update: 样式更新")]),t._v(" "),e("li",[t._v("style-remove: 样式移除")]),t._v(" "),e("li",[t._v("js-update: js 文件更新")]),t._v(" "),e("li",[t._v("full-reload: fallback 机制，网页重刷新")])]),t._v(" "),e("p",[t._v("其中针对 Vue 组件本身的一些更新，都可以直接调用 HMRRuntime 提供的方法，非常方便。其余的更新逻辑，基本上都是利用了 timestamp 刷新缓存重新执行的方法来达到更新的目的。")]),t._v(" "),e("h3",{attrs:{id:"服务端"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务端"}},[t._v("#")]),t._v(" 服务端")]),t._v(" "),e("p",[t._v("核心是监听项目文件的变更，然后根据不同文件类型（目前只有 vue 和 js）来做不同的处理：")]),t._v(" "),e("p",[t._v("对于 vue 文件的热更新而言，主要是重新编译 Vue 文件，检测 template 、script 、style 的改动，如果有改动就通过 WS 服务端发起对应的热更新请求。")]),t._v(" "),e("p",[t._v("对于热更新 js 文件而言，会递归地查找引用这个文件的 importer。比如是某个 Vue 文件所引用了这个 js，就会被查找出来。假如最终发现找不到引用者，则会返回 hasDeadEnd: true。")])])}),[],!1,null,null,null);s.default=r.exports}}]);