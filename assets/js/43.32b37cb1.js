(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{394:function(e,v,_){"use strict";_.r(v);var t=_(25),a=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"js中的事件循环"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js中的事件循环"}},[e._v("#")]),e._v(" JS中的事件循环")]),e._v(" "),_("p",[_("code",[e._v("JS")]),e._v(" 中的事件循环机制")]),e._v(" "),_("h2",{attrs:{id:"进程与线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[e._v("#")]),e._v(" 进程与线程")]),e._v(" "),_("p",[_("code",[e._v("JS")]),e._v(" 是单线程执行的，讲到线程，那么也得说一下进程，本质上来说，两个名词都是 "),_("code",[e._v("CPU")]),e._v(" 工作时间片的一个描述。")]),e._v(" "),_("p",[e._v("进程描述了 "),_("code",[e._v("CPU")]),e._v(" 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间。")]),e._v(" "),_("p",[e._v("当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等，当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。")]),e._v(" "),_("h2",{attrs:{id:"浏览器中的-event-loop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器中的-event-loop"}},[e._v("#")]),e._v(" 浏览器中的 Event Loop")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/PENG_YUE/myImg/raw/master/uPic/Lgi6hI.png",alt:"img"}})]),e._v(" "),_("p",[e._v("Event Loop 执行顺序:")]),e._v(" "),_("ol",[_("li",[e._v("首先执行同步代码，这属于宏任务")]),e._v(" "),_("li",[e._v("当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行")]),e._v(" "),_("li",[e._v("执行所有微任务")]),e._v(" "),_("li",[e._v("当执行完所有微任务后，如有必要会渲染页面")]),e._v(" "),_("li",[e._v("然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数")])]),e._v(" "),_("p",[e._v("微任务包括: "),_("code",[e._v("process.nextTick")]),e._v("，"),_("code",[e._v("promise")]),e._v(" ，"),_("code",[e._v("MutationObserver")]),e._v("，其中 "),_("code",[e._v("process.nextTick")]),e._v(" 为 "),_("code",[e._v("Node")]),e._v(" 独有。\n宏任务包括 "),_("code",[e._v("script")]),e._v(","),_("code",[e._v("setTimeout")]),e._v(", "),_("code",[e._v("setInterval")]),e._v(","),_("code",[e._v("setImmediate")]),e._v(","),_("code",[e._v("I/O")]),e._v(","),_("code",[e._v("UI rendering")]),e._v("。")]),e._v(" "),_("h2",{attrs:{id:"node-中的-event-loop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#node-中的-event-loop"}},[e._v("#")]),e._v(" Node 中的 Event Loop")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/PENG_YUE/myImg/raw/master/uPic/OIprvT.png",alt:"img"}})]),e._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/PENG_YUE/myImg/raw/master/uPic/yeag8u.png",alt:"img"}})]),e._v(" "),_("p",[e._v("Node 中的 Event Loop 和浏览器中的是完全不相同的东西。\nNode 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量达到系统的阀值，就会进入下一个阶段。")]),e._v(" "),_("h3",{attrs:{id:"timer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#timer"}},[e._v("#")]),e._v(" timer")]),e._v(" "),_("p",[_("code",[e._v("timers")]),e._v(" 阶段会执行 "),_("code",[e._v("setTimeout")]),e._v(" 和 "),_("code",[e._v("setInterval")]),e._v(" 的回调，并且是由 poll 阶段控制的。\n所以在node中的定时器指定的时间也不是准确时间，只能是尽快执行。")]),e._v(" "),_("h3",{attrs:{id:"i-o，callback阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#i-o，callback阶段"}},[e._v("#")]),e._v(" I/O，callback阶段")]),e._v(" "),_("p",[e._v("执行除了"),_("code",[e._v("close")]),e._v("事件的"),_("code",[e._v("callbacks")]),e._v("、被"),_("code",[e._v("timers")]),e._v("设定的"),_("code",[e._v("callbacks")]),e._v(","),_("code",[e._v("setImmediate()")]),e._v("设定的"),_("code",[e._v("callbacks")]),e._v("这些之外的"),_("code",[e._v("callbacks")]),e._v("，"),_("code",[e._v("I/O")]),e._v("阶段会执行上一轮循环中少数未执行的"),_("code",[e._v("I/O")]),e._v("回调.")]),e._v(" "),_("h3",{attrs:{id:"idle-prepare"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#idle-prepare"}},[e._v("#")]),e._v(" idle,prepare")]),e._v(" "),_("p",[e._v("仅供 "),_("code",[e._v("node")]),e._v(" 内部使用.")]),e._v(" "),_("h3",{attrs:{id:"poll"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#poll"}},[e._v("#")]),e._v(" poll")]),e._v(" "),_("p",[e._v("这一阶段中，系统会做两件事情")]),e._v(" "),_("ol",[_("li",[e._v("回到 "),_("code",[e._v("timer")]),e._v(" 阶段执行回调")]),e._v(" "),_("li",[e._v("执行 "),_("code",[e._v("I/O")]),e._v(" 回调")])]),e._v(" "),_("ul",[_("li",[e._v("如果 "),_("code",[e._v("poll")]),e._v(" 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制")]),e._v(" "),_("li",[e._v("如果 "),_("code",[e._v("poll")]),e._v(" 队列为空时，会有两件事发生\n"),_("ul",[_("li",[e._v("如果有 "),_("code",[e._v("setImmediate")]),e._v(" "),_("code",[e._v("回调需要执行，poll")]),e._v(" 阶段会停止并且进入到 check 阶段执行回调")]),e._v(" "),_("li",[e._v("如果没有 "),_("code",[e._v("setImmediate")]),e._v(" 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去")])])])]),e._v(" "),_("p",[e._v("当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。")]),e._v(" "),_("h3",{attrs:{id:"check"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#check"}},[e._v("#")]),e._v(" check")]),e._v(" "),_("p",[_("code",[e._v("check")]),e._v(" 阶段执行 "),_("code",[e._v("setImmediate")])]),e._v(" "),_("h3",{attrs:{id:"close-callbacks"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#close-callbacks"}},[e._v("#")]),e._v(" close callbacks")]),e._v(" "),_("p",[e._v("执行socket.on('close', ....)这些callbacks")]),e._v(" "),_("h3",{attrs:{id:"nodejs中宏队列主要有4个"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nodejs中宏队列主要有4个"}},[e._v("#")]),e._v(" NodeJS中宏队列主要有4个")]),e._v(" "),_("p",[e._v("由上面的介绍可以看到，回调事件主要位于4个 "),_("code",[e._v("macrotask queue")]),e._v(" 中：")]),e._v(" "),_("ol",[_("li",[e._v("Timers Queue")]),e._v(" "),_("li",[e._v("IO Callbacks Queue")]),e._v(" "),_("li",[e._v("Check Queue")]),e._v(" "),_("li",[e._v("Close Callbacks Queue")])]),e._v(" "),_("p",[e._v("不同类型的 "),_("code",[e._v("macrotask queue")]),e._v(" 会被放入不同的宏任务队列中。在浏览器中")]),e._v(" "),_("p",[e._v("NodeJs的微任务队列主要有2个：")]),e._v(" "),_("p",[_("code",[e._v("Next Tick Queue")]),e._v("：是放置process.nextTick(callback)的回调任务的\n"),_("code",[e._v("Other Micro Queue")]),e._v("：放置其他microtask，比如Promise等")]),e._v(" "),_("p",[e._v("node在11版本之后的eventloop执行与浏览器一致了")])])}),[],!1,null,null,null);v.default=a.exports}}]);