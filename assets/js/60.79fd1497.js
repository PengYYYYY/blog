(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{411:function(a,t,s){"use strict";s.r(t);var r=s(25),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"redis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[a._v("#")]),a._v(" redis")]),a._v(" "),s("p",[a._v("redis是一个开源数据的kv数据库，它的数据放置于内存当中，常用来做缓存服务器。")]),a._v(" "),s("h2",{attrs:{id:"特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),s("ul",[s("li",[a._v("速度快，因为数据在内存当中，类似于HashMap")]),a._v(" "),s("li",[a._v("支持丰富的数据类型，string, list, set, hash")]),a._v(" "),s("li",[a._v("支持事物，操作都是原子性的")]),a._v(" "),s("li",[a._v("丰富的特性，应用场景广泛")])]),a._v(" "),s("h2",{attrs:{id:"应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[a._v("#")]),a._v(" 应用场景")]),a._v(" "),s("h3",{attrs:{id:"缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[a._v("#")]),a._v(" 缓存")]),a._v(" "),s("p",[a._v("因为redis的读取性能优异，每秒可以处理超过10w次的读写操作。redis可以保存多种数据结构，单个value的最大限制是1GB,而memcached只能保存1md的数据。")]),a._v(" "),s("h3",{attrs:{id:"分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[a._v("#")]),a._v(" 分布式锁")]),a._v(" "),s("p",[a._v("因为redis单线程的特点，对于高并发系统，都是用多服务器部署，在进行逻辑处理的时候可以用到分布式锁来限制程序的并发。")]),a._v(" "),s("h3",{attrs:{id:"自动过期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自动过期"}},[a._v("#")]),a._v(" 自动过期")]),a._v(" "),s("p",[a._v("redis针对数据都可以设置过期时间，可以自动清理过期数据，常见的应用场景：短信验证码，活动开始和截止日期等。")]),a._v(" "),s("h3",{attrs:{id:"秒杀的缓存层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#秒杀的缓存层"}},[a._v("#")]),a._v(" 秒杀的缓存层")]),a._v(" "),s("p",[a._v("可以利用redis单线程的特性来控制并发，将redis作为缓存平台，由于其读写能力强，不易产生程序阻塞现象。")]),a._v(" "),s("h3",{attrs:{id:"发布订阅"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅"}},[a._v("#")]),a._v(" 发布订阅")]),a._v(" "),s("p",[a._v("可以使用redis的发布订阅模式实现一些聊天系统。")]),a._v(" "),s("h2",{attrs:{id:"redis问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis问题"}},[a._v("#")]),a._v(" redis问题")]),a._v(" "),s("h3",{attrs:{id:"缓存雪崩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[a._v("#")]),a._v(" 缓存雪崩")]),a._v(" "),s("p",[a._v("缓存雪崩，是指缓存中设置了大批量相同过期时间的数据同时过期失效，而在这一刻访问量剧增，缓存近乎失效，所有请求全部转向DB，DB瞬时压力过重雪崩，甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。")]),a._v(" "),s("p",[a._v("解决方案：")]),a._v(" "),s("ul",[s("li",[a._v("设置热点数据永不过期。")]),a._v(" "),s("li",[a._v("过期时间设置随机，防止同一时间大量数据过期现象发生。")]),a._v(" "),s("li",[a._v("若redis缓存是分布式部署，可以把热点数据均匀分布在不同缓存数据库中。")])]),a._v(" "),s("h3",{attrs:{id:"缓存穿透"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[a._v("#")]),a._v(" 缓存穿透")]),a._v(" "),s("p",[a._v("缓存穿透是指查询一个缓存和数据库中都没有的数据，由于大部分缓存策略是被动加载的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。用户不断发起请求，在流量大时，就可能对DB形成巨大的压力，利用不存在的key频繁攻击应用也是很大的问题。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("缓存和数据库中都不存在的数据，可以将此key对应的value设置为一个默认的值，比如“NULL”，并设置一个缓存的失效时间，这时在缓存失效之前，所有通过此key的访问都被缓存挡住了。后面如果此key对应的数据在DB中存在时，缓存失效之后，通过此key再去访问数据，就能拿到新的value了。")])]),a._v(" "),s("li",[s("p",[a._v("接口层增加校验，比如用户鉴权校验，id根据数据场景做基础校验，id<=0的直接拦截。")])])]),a._v(" "),s("h3",{attrs:{id:"缓存击穿"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[a._v("#")]),a._v(" 缓存击穿")]),a._v(" "),s("p",[a._v("缓存击穿是指缓存中的一个热点Key(比如一个秒杀商品)，在某个时间点过期的时候，恰好在这个时间点访问量剧增，对这个Key有大量的并发请求过来，请求发现缓存过期一般都会从后端DB加载数据并回设回缓存，但就在缓存中的数据还没有完全从DB中加载过来的这个时间段期间，并发瞬间造成大量请求直接击穿到DB，对DB形成巨大压力。")]),a._v(" "),s("p",[a._v("缓存击穿，又叫热点key问题，是这三个问题中最经典的一个问题。")]),a._v(" "),s("ul",[s("li",[a._v("设置热点数据永不过期。")]),a._v(" "),s("li",[a._v("资源保护，服务降级。")])]),a._v(" "),s("h3",{attrs:{id:"缓存雪崩和缓存击穿的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩和缓存击穿的区别"}},[a._v("#")]),a._v(" 缓存雪崩和缓存击穿的区别")]),a._v(" "),s("p",[a._v("缓存击穿跟缓存雪崩类似，区别就是缓存雪崩是群体失效，缓存击穿是单体失效。")])])}),[],!1,null,null,null);t.default=v.exports}}]);