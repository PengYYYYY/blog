(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{360:function(t,v,_){"use strict";_.r(v);var a=_(25),l=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"复杂度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#复杂度"}},[t._v("#")]),t._v(" 复杂度")]),t._v(" "),_("p",[t._v("复杂度可以衡量算法的好坏。分析复杂度的同时，也是模拟运算的过程。")]),t._v(" "),_("h2",{attrs:{id:"时间复杂度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[t._v("#")]),t._v(" 时间复杂度")]),t._v(" "),_("p",[t._v("实际是指程序运行次数，而不是程序运行时间")]),t._v(" "),_("ul",[_("li",[t._v("O(1):常数阶")]),t._v(" "),_("li",[t._v("O(log2 n):对数阶")]),t._v(" "),_("li",[t._v("O(n):线性阶")]),t._v(" "),_("li",[t._v("O(nlog2n):线性对数阶")]),t._v(" "),_("li",[t._v("O(n^2):平方型")]),t._v(" "),_("li",[t._v("O(n^3):立方型")]),t._v(" "),_("li",[t._v("O(2^n):指数型")]),t._v(" "),_("li",[t._v("O(2^n):阶乘阶")])]),t._v(" "),_("h2",{attrs:{id:"空间复杂度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度"}},[t._v("#")]),t._v(" 空间复杂度")]),t._v(" "),_("p",[t._v("算法执行时创建的变量（包括临时变量）个数")]),t._v(" "),_("ul",[_("li",[t._v("忽略常数，用O(1)表示")]),t._v(" "),_("li",[t._v("递归算法的空间复杂度 = 递归深度N * 每次递归所要的辅助空间")]),t._v(" "),_("li",[t._v("对于单线程来说，递归有运行时堆栈，求的是递归最深的那一次压栈所耗费的空间的个数，因为递归最深的那一次所耗费的空间足以容纳它所有递归过程。递归是要返回上一层的，所以它所需要的空间不是一直累加起来的")])])])}),[],!1,null,null,null);v.default=l.exports}}]);