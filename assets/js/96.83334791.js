(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{371:function(v,t,_){"use strict";_.r(t);var a=_(25),e=Object(a.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[v._v("#")]),v._v(" 缓存")]),v._v(" "),_("h2",{attrs:{id:"http缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http缓存"}},[v._v("#")]),v._v(" http缓存")]),v._v(" "),_("ul",[_("li",[v._v("浏览器缓存即http缓存，将数据缓存在浏览器(即客户端)。")]),v._v(" "),_("li",[v._v("服务端通过设置HTTP响应头来决定缓存策略，将资源缓存到本地浏览器。")])]),v._v(" "),_("p",[v._v("Web缓存的作用")]),v._v(" "),_("ul",[_("li",[v._v("提高首屏加载速度->优化用户体验")]),v._v(" "),_("li",[v._v("减少流量消耗")]),v._v(" "),_("li",[v._v("减轻服务器压力")])]),v._v(" "),_("h3",{attrs:{id:"工作流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#工作流程"}},[v._v("#")]),v._v(" 工作流程")]),v._v(" "),_("ul",[_("li",[v._v("第一次请求资源，服务器返回对应资源，并在response header响应头中添加缓存策略。")]),v._v(" "),_("li",[v._v("第二次请求时，浏览器判断请求参数，命中强缓存就直接200，从本地缓存中拿数据。否则把响应参数存在request header请求头中，看是否命中协商缓存，命中则返回304，否则服务器会返回全新资源。")])]),v._v(" "),_("h3",{attrs:{id:"强缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[v._v("#")]),v._v(" 强缓存")]),v._v(" "),_("ul",[_("li",[v._v("直接拿本地副本对比读取，不读服务器，返回状态码是200")]),v._v(" "),_("li",[v._v("使用定时器的方式，让强缓存设置静态资源的有效期，如果超过有效期则认为缓存作废。")]),v._v(" "),_("li",[v._v("无需与服务端发生交互")])]),v._v(" "),_("h4",{attrs:{id:"expires"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[v._v("#")]),v._v(" Expires")]),v._v(" "),_("p",[v._v("HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求的结果缓存的到期时间，即再次发送请求时如果客户端的时间小于Expires的值时，直接使用缓存结果。在HTTP/1.1，Expires已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，如果时间发生误差，那么强制缓存将直接失效。")]),v._v(" "),_("h4",{attrs:{id:"cache-control"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[v._v("#")]),v._v(" Cache-Control")]),v._v(" "),_("p",[v._v("Cache-Control是最重要的规则，主要用于控制网页缓存。")]),v._v(" "),_("ul",[_("li",[v._v("public:所有内容都将被缓存（客户端和代理服务器都可缓存)")]),v._v(" "),_("li",[v._v("private:所有内容只有客户端可以缓存，Cache-Control的默认取值")]),v._v(" "),_("li",[v._v("no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定")]),v._v(" "),_("li",[v._v("no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存")]),v._v(" "),_("li",[v._v("max-age=xx：缓存在xxx秒后失效。")]),v._v(" "),_("li",[v._v("must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。")])]),v._v(" "),_("p",[v._v("在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择。")]),v._v(" "),_("p",[v._v("Cache-Control字段是http报文中的通用首部字段，既存在于请求报文中，也存在于响应报文中")]),v._v(" "),_("blockquote",[_("p",[v._v("共有字段：\nno-cache：无论缓存是否过期，都要对请求进行校验\nno-store：请求报文中可能存在机密信息，不可缓存 （缓存字段中优先级最高）\nmax-age=[秒]：资源x秒后过期，未过期则使用缓存\nno-transform：禁止代理改变实体主体的媒体类型，也包括压缩\ncache-extension： 自定义拓展值，如果缓存服务器不能理解，则忽略")])]),v._v(" "),_("blockquote",[_("p",[v._v("请求报文私有字段值：\nmax-stale(=[秒])： 提示缓存服务器，即使缓存过期也使用；或者在过期后的指定时间内依然使用缓存\nmin-fresh(=[秒])： 提示缓存服务器，如果缓存在指定时间内还没过期，则返回\nonly-if-cache： 提示服务器如果有缓存就返回，不需要确认有效性。如果没有，则返回504网关超时")])]),v._v(" "),_("blockquote",[_("p",[v._v("响应报文私有字段值：")])]),v._v(" "),_("p",[v._v("public： 明确指明缓存可以给所有用户使用\nprivate： 明确指明缓存不可以给其他用户使用\nmust-revalidate： 如果缓存未过期，则返回；否则代理在返回缓存数据之前，必须向源服务器发起请求，验证缓存是否有效。如果无法连接上源服务器，则返回504网关超时\nproxy-revalidate： 所有缓存服务器在返回缓存数据前，都要向源服务器发起请求验证有效性\ns-maxage=[秒]： 缓存资源的时间小于指定时间时，直接返回缓存")]),v._v(" "),_("h4",{attrs:{id:"pragma"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#pragma"}},[v._v("#")]),v._v(" Pragma")]),v._v(" "),_("p",[v._v("Pragma 是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同。但是HTTP的响应头没有明确定义这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。")]),v._v(" "),_("p",[v._v("优先级顺序为：Pragma>Cache-Control>Expires")]),v._v(" "),_("h3",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[v._v("#")]),v._v(" 协商缓存")]),v._v(" "),_("ul",[_("li",[v._v("协商缓存指的是浏览器和服务器之间是否要使用缓存在做协商。如果协商的结果是需要更新会返回200并返回更新内容。如果不需要只需要返回状态码304不用返回内容，只是需要后端做应答，但是不需要后端重新生成内容。")]),v._v(" "),_("li",[v._v("协商缓存：需要与服务端发生交互，判断是否使用本地缓存的文件。")])]),v._v(" "),_("h3",{attrs:{id:"last-modified-if-modified-since"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-if-modified-since"}},[v._v("#")]),v._v(" Last-modified & if-modified-since")]),v._v(" "),_("p",[v._v("这是一组通过协商修改时间为基础的策略。")]),v._v(" "),_("ul",[_("li",[v._v("服务器向后端发送一个数据上次被修改的时间标签。")]),v._v(" "),_("li",[v._v("浏览器知道了服务器资源上次修改的时间，后续请求中，会和服务器进行时间的比较，如果服务器上的时间比本地时间要新，说明数据有更改，浏览器需要重新下载数据。")])]),v._v(" "),_("h3",{attrs:{id:"etag"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[v._v("#")]),v._v(" ETag")]),v._v(" "),_("p",[v._v("通过内容判断，一般的做法是将返回内容进行摘要，然后通过对比来判断内容是否需要更新。")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("用户操作")]),v._v(" "),_("th",[v._v("Expires/Cache-Control")]),v._v(" "),_("th",[v._v("Last-modified/ETag")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("地址栏回车")]),v._v(" "),_("td",[v._v("有效")]),v._v(" "),_("td",[v._v("有效")])]),v._v(" "),_("tr",[_("td",[v._v("页面链接跳转")]),v._v(" "),_("td",[v._v("有效")]),v._v(" "),_("td",[v._v("有效")])]),v._v(" "),_("tr",[_("td",[v._v("新开窗口")]),v._v(" "),_("td",[v._v("有效")]),v._v(" "),_("td",[v._v("有效")])]),v._v(" "),_("tr",[_("td",[v._v("前进后退")]),v._v(" "),_("td",[v._v("有效")]),v._v(" "),_("td",[v._v("有效")])]),v._v(" "),_("tr",[_("td",[v._v("F5刷新")]),v._v(" "),_("td",[v._v("无效")]),v._v(" "),_("td",[v._v("有效")])]),v._v(" "),_("tr",[_("td",[v._v("强制刷新")]),v._v(" "),_("td",[v._v("无效")]),v._v(" "),_("td",[v._v("无效")])])])]),v._v(" "),_("h2",{attrs:{id:"ajax缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ajax缓存"}},[v._v("#")]),v._v(" Ajax缓存")]),v._v(" "),_("h3",{attrs:{id:"定时缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#定时缓存"}},[v._v("#")]),v._v(" 定时缓存")]),v._v(" "),_("p",[v._v("将某个接口数据在一定时间段内缓存起来，缓存期内不再发起请求直接返回本地数据，过了这段时间再重新获取并更新缓存。\n定时缓存实际上是牺牲了数据实时性换取响应速度，使用中通过设置不同的缓存时长，可以匹配不同的业务场景，比如对于相对稳定的数据可以设置较长的缓存时间，而设置较短的缓存时间则可以起到请求“防抖”作用。")]),v._v(" "),_("h3",{attrs:{id:"快照缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#快照缓存"}},[v._v("#")]),v._v(" 快照缓存")]),v._v(" "),_("p",[v._v("更多的时候我们希望接口能兼具实时性和响应速度，比如应用首屏的异步数据块，既要快又要新，虽然这种需求听起来很“不科学”，但我们确实可以通过“快照缓存”满足这个需求。此时每当接口成功请求后都会为数据建立一份“快照”。下次请求时接口会首先将最近的快照数据作为结果返回，供前端渲染界面，同时发送请求获取最新数据，新数据到达后会与快照做对比，如果与快照相同则缓存命中，如果与快照不同会更新快照，并将新数据返回，供前端更新界面。")]),v._v(" "),_("h2",{attrs:{id:"serviceworker"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#serviceworker"}},[v._v("#")]),v._v(" ServiceWorker")]),v._v(" "),_("p",[v._v("Service Worker 是HTML5 的一个新特性，主要用来做持久的离线缓存")]),v._v(" "),_("h3",{attrs:{id:"serviceworker可以干嘛"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#serviceworker可以干嘛"}},[v._v("#")]),v._v(" ServiceWorker可以干嘛")]),v._v(" "),_("p",[v._v("解放主线程，"),_("code",[v._v("Web Worker")]),v._v(" 是脱离在主线程之外的，将一些复杂的耗时的活交给它干，完成后通过 "),_("code",[v._v("postMessage")]),v._v(" 方法告诉主线程，而主线程通过 "),_("code",[v._v("onMessage")]),v._v(" 方法得到 "),_("code",[v._v("Web Worker")]),v._v(" 的结果反馈。")]),v._v(" "),_("h3",{attrs:{id:"优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),_("ul",[_("li",[v._v("省去建立tcp的连接时长，加快首屏加载速度")]),v._v(" "),_("li",[v._v("减少静态资源服务器的负载")])]),v._v(" "),_("h3",{attrs:{id:"功能与特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#功能与特性"}},[v._v("#")]),v._v(" 功能与特性")]),v._v(" "),_("ul",[_("li",[v._v("Service Worker拥有自己独立的 worker 线程，独立于当前网页线程")]),v._v(" "),_("li",[v._v("离线缓存静态资源")]),v._v(" "),_("li",[v._v("拦截代理请求和响应")]),v._v(" "),_("li",[v._v("可自定义响应内容")]),v._v(" "),_("li",[v._v("可以通过postMessage向主线程发送消息")]),v._v(" "),_("li",[v._v("无法直接操作DOM")]),v._v(" "),_("li",[v._v("必须在HTTPS环境下工作,或者本地。")]),v._v(" "),_("li",[v._v("通过Promise异步实现")]),v._v(" "),_("li",[_("code",[v._v("Service Worker")]),v._v(" 安装(installing)完成后，就会一直存在，除非手动卸载(unregister)")])]),v._v(" "),_("h3",{attrs:{id:"生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[v._v("#")]),v._v(" 生命周期")]),v._v(" "),_("p",[_("code",[v._v("Service Worker")]),v._v(" 的生命周期完全独立于网页")]),v._v(" "),_("ul",[_("li",[v._v("注册 (register)")]),v._v(" "),_("li",[v._v("安装 (install)")]),v._v(" "),_("li",[v._v("激活 (activate)")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/PENG_YUE/myImg/raw/master/uPic/399lNn.png",alt:"img"}})]),v._v(" "),_("h4",{attrs:{id:"使用-service-worker-只需要以下几个步骤"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用-service-worker-只需要以下几个步骤"}},[v._v("#")]),v._v(" 使用 service worker 只需要以下几个步骤")]),v._v(" "),_("ol",[_("li",[v._v("检测是否支持serivceworker")]),v._v(" "),_("li",[v._v("注册(register)")]),v._v(" "),_("li",[v._v("安装(install)")]),v._v(" "),_("li",[v._v("激活(active)")]),v._v(" "),_("li",[v._v("使用(activing)")]),v._v(" "),_("li",[v._v("卸载(unregister)")])])])}),[],!1,null,null,null);t.default=e.exports}}]);