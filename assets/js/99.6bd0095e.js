(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{369:function(t,_,v){"use strict";v.r(_);var a=v(25),r=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"http-next"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-next"}},[t._v("#")]),t._v(" http-next")]),t._v(" "),v("h2",{attrs:{id:"http2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http2"}},[t._v("#")]),t._v(" http2")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("一个TCP⻓连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动。同时也避免了多个TCP连接竞争带宽所带来的问题。")])]),t._v(" "),v("li",[v("p",[t._v("队头阻塞，资源并行请求，")])]),t._v(" "),v("li",[v("p",[t._v("多路复用机制，个请求都有一个对应的 ID，在浏览器端，就可以随时将请求发送给服务器了。将请求分成一帧一帧的数据去传输。当收到一个优先级高的请求时，服务器可以暂停之前的请求来优先处理关键资源的请求。")])])]),t._v(" "),v("h3",{attrs:{id:"二进制分帧"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二进制分帧"}},[t._v("#")]),t._v(" 二进制分帧")]),t._v(" "),v("p",[t._v("帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。")]),t._v(" "),v("p",[t._v("流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。")]),t._v(" "),v("p",[t._v("HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。")]),t._v(" "),v("p",[t._v("HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。")]),t._v(" "),v("h3",{attrs:{id:"多路复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[t._v("#")]),t._v(" 多路复用")]),t._v(" "),v("p",[t._v("多路复用，代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP连接并发完成。 HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。")]),t._v(" "),v("p",[t._v("在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中：")]),t._v(" "),v("ul",[v("li",[t._v("同域名下所有通信都在单个连接上完成。")]),t._v(" "),v("li",[t._v("单个连接可以承载任意数量的双向数据流。")]),t._v(" "),v("li",[t._v("数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。")])]),t._v(" "),v("p",[t._v("性能提升：")]),t._v(" "),v("ul",[v("li",[t._v("同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗。")]),t._v(" "),v("li",[t._v("单个连接上可以并行交错的请求和响应，之间互不干扰。")]),t._v(" "),v("li",[t._v("在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级，数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。")])]),t._v(" "),v("h3",{attrs:{id:"服务器推送"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务器推送"}},[t._v("#")]),t._v(" 服务器推送")]),t._v(" "),v("p",[t._v("服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。")]),t._v(" "),v("p",[t._v("服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。")]),t._v(" "),v("h3",{attrs:{id:"头部压缩"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#头部压缩"}},[t._v("#")]),t._v(" 头部压缩")]),t._v(" "),v("p",[t._v("HTTP/2对消息头采用HPACK（专为http/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。")]),t._v(" "),v("ul",[v("li",[t._v("HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；")]),t._v(" "),v("li",[t._v("首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;")]),t._v(" "),v("li",[t._v("每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。")])]),t._v(" "),v("h3",{attrs:{id:"http2请求过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http2请求过程"}},[t._v("#")]),t._v(" Http2请求过程")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是POST方法，那么还要有请求体。")])]),t._v(" "),v("li",[v("p",[t._v("这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求ID编号的帧，通过协议栈将这些帧发送给服务器。")])]),t._v(" "),v("li",[v("p",[t._v("服务器接收到所有帧之后，会将所有相同ID的帧合并为一条完整的请求信息。")])]),t._v(" "),v("li",[v("p",[t._v("然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。")])]),t._v(" "),v("li",[v("p",[t._v("同样，二进制分帧层会将这些响应数据转换为一个个带有请求ID编号的帧，经过协议栈发送给浏览器。")])]),t._v(" "),v("li",[v("p",[t._v("浏览器接收到响应帧之后，会根据ID编号将帧的数据提交给对应的请求。")])])]),t._v(" "),v("p",[t._v("通过引入二进制分帧层，就实现了HTTP的多路复用技术。")]),t._v(" "),v("h2",{attrs:{id:"http3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http3"}},[t._v("#")]),t._v(" http3")]),t._v(" "),v("p",[t._v("QUIC（quick upd internet connection）,")]),t._v(" "),v("p",[t._v("QUIC协议有以下特点：")]),t._v(" "),v("ul",[v("li",[t._v("基于UDP的传输层协议：它使用UDP端口号来识别指定机器上的特定服务器。")]),t._v(" "),v("li",[t._v("可靠性：虽然UDP是不可靠传输协议，但是QUIC在UDP的基础上做了些改造，使得他提供了和TCP类似的可靠性。它提供了数据包重传、拥塞控制、调整传输节奏以及其他一些TCP中存在的特性。")]),t._v(" "),v("li",[t._v("实现了无序、并发字节流：QUIC的单个数据流可以保证有序交付，但多个数据流之间可能乱序，这意味着单个数据流的传输是按序的，但是多个数据流中接收方收到的顺序可能与发送方的发送顺序不同！")]),t._v(" "),v("li",[t._v("快速握手：QUIC提供0-RTT和1-RTT的连接建立")]),t._v(" "),v("li",[t._v("使用TLS 1.3传输层安全协议：与更早的TLS版本相比，TLS 1.3有着很多优点，但使用它的最主要原因是其握手所花费的往返次数更低，从而能降低协议的延迟。")])]),t._v(" "),v("p",[t._v("QUIC建立流程：")]),t._v(" "),v("blockquote",[v("p",[t._v("Diffie–Hellman (以下简称DH)密钥交换是一个特殊的交换密钥的方法。它是密码学领域内最早付诸实践的密钥交换方法之一。 DH可以让双方在完全缺乏对方(私有)信息的前提条件下通过不安全的信道达成一个共享的密钥。此密钥用于对后续信息交换进行对称加密。")])]),t._v(" "),v("p",[t._v("QUIC在握手过程中使用Diffie-Hellman算法协商初始密钥，初始密钥依赖于服务器存储的一组配置参数，该参数会周期性的更新。初始密钥协商成功后，服务器会提供一个临时随机数，双方根据这个数再生成会话密钥。客户端和服务器会使用新生的的密钥进行数据加解密。")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://juejin.cn/post/6908522467107536903",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://juejin.cn/post/6908522467107536903"),v("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=r.exports}}]);