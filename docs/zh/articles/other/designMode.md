# 设计模式入门

## 创建型模式

- 工厂模式

其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

- 原型模式

能够复制已有对象， 而又无需使代码依赖它们所属的类，链式结构。

- 单例模式

多个共享一个

## 结构型模式

- 装饰器模式

允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

- 代理模式

让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。

- 适配器模式

它能使接口不兼容的对象能够相互合作。

- 桥接模式

可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。

- 组合模式

你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。

- 外观模式

能为程序库、 框架或其他复杂类提供一个简单的接口。

- 享元模式

它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。

## 行为模式

- 责任链模式

允许你将请求沿着处理者链进行发送。收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。

- 命令模式

它可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。

- 迭代器模式

让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。

- 中介者模式

能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。

- 备忘录模式

允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。

- 观察者模式

允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。

- 状态模式

让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。

- 策略模式

它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。

- 模板方法模式

它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。

- 访问者模式

它能将算法与其所作用的对象隔离开来
