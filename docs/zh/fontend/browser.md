# Browser

## 单进程浏览器与多进程浏览器

### 进程与线程

一个进程就是一个程序的运行实例。启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码，运行中的数据和一个执行任务的主线程，一个这样的运行环境叫进程。

线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

进程与线程之间的关系：

- 进程中的任意一线程执行出错，都会导致整个进程崩溃
- 线程之间共享进程中的数据
- 当一个进程关闭之后，操作系统会回收进程所占用的内存
- 进程之间的内容相互隔离，如果需要进程中的通信，就需要使用用于进程间通信(IPC)的机制了。

### 单进程浏览器

单进程浏览 器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、 JavaScript 运行环境、渲染引擎和页面等。导致浏览器`不稳定`、`不流畅`和`不安全`。

- 不稳定：浏览器插件容易出问题，出问题以后会导致整个进程的崩溃。渲染引擎模块在引入一些复杂的JavaScript代码时也会崩溃。

- 不流畅：由于单进程模型，在同一时刻中，只能有一个模块运行。在耗时脚本中，在其执行过程中，会独占整个线程，导致其他任务无法执行，会造成卡顿的现象。页面的内存泄漏也是单进程变慢的一个重要原因。运行一个复杂点的页面再关闭页面，会存在 内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得 越慢。

- 不安全：通过插件可以获取到操作系统的任意资源，所以当运行一个插件时，也就意味着这个插件能完全操控操作系统。如果是恶意插件，则会引起安全问题。同样的，页面的恶意脚本也可以进行此类操作

### 多进程浏览器

多进程浏览器架构中，页面是运行在单独的渲染进程中的，同时页面中的插件也运行在单独的插件进程中，进程之间通过`ipc(inter-Process Communication)`机制进行通信

#### 如何解决不稳定的问题

由于进程是相互隔离的，所以当一个页面或者插件崩溃 时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就 完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。

#### 如何解决不流畅问题

JavaScript 也是运行在渲染进程中 的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影 响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的

对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收。

#### 如何解决安全问题

采用多进程架构的额外好处是可以使用`安全沙箱`，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里 面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。

### 最新的多进程架构

最新的 Chrome 浏览器包括:1 个浏览器(Browser)主进程、1 个 GPU 进程、1 个网络(NetWork)进程、多个渲染进程和多个插件进程。

- 浏览器进程: 主要负责界面显示、用户交互、子进程管理，同时提供存储等功能.
- 渲染进程: 核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页， 排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会 为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下.
- GPU 进程: 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷 是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘 制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- 网络进程: 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面 的，直至最近才独立出来，成为一个单独的进程。
- 插件进程: 主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保 证插件进程崩溃不会对浏览器和页面造成影响。

打开一个chrome页面：最少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，如果有运行插件的话，还需要一个插件进程。

### 多进程架构带来的问题

- 更高的资源占用： 因为每个进程都会包含公共基础结构的副本(如 JavaScript 运行环 境)，这就意味着浏览器会消耗更多的内存资源。
- 更复杂的体系架构： 浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已 经很难适应新的需求了。

### 未来面向服务的架构

面向服务的架构(Services Oriented Architecture，简称SOA)，把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统 底层服务。如果把Chrome抽象为`便携式操作系统`，Chrome 基础服务便可以被视为该操作系统的`基础`系统服务层。

同时`Chrome`还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服 务，但是如果在资源受限的设备上，Chrome 会将很多服务整合到一个进程中，从而节省内存占用。

## 浏览器的网络请求

浏览器端发起 HTTP 请求流程

- 构建请求

```
GET /index.html HTTP1.1
```

- 查找缓存

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。命中缓存，返回该资源的副本，并直接结束请求。否则继续请求。

- 准备 IP 地址和端口

第一步浏览器会请求DNS 返回域名对应的IP。当 然浏览器还提供了DNS数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。拿到IP 之后，接下来就需要获取端口号了。通常情况下，如果URL没有特别指明端口 号，那么HTTP协议默认是80端口。

- 等待TCP队列

Chrome有个机制，同一个域名同时最多只能建立6个TCP连接， 如果在同一个域名下同时有10个请求发生，其中4个请求会进入排队等待状态，直到进行中的请求完成。

- 建立TCP连接

排队等待结束后，浏览器通过TCP与服务器连接

- 发送 HTTP 请求

首先浏览器会向服务器发送请求行，包括了请求方法，请求URI,HTTP协议。发送请求行就是告诉服务器需要什么资源。
发送请求体，把信息告诉服务器，发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础 信息告诉服务器。

- 服务端处理HTTP请求

服务器会返回响应行，包括协议版本和状态码，发送响应体

- 断开连接

一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，当配置了`Connection:Keep-Alive`属性,tcp连接会被保持打开状态，这样浏览器可以通过同一个TCP连接发送请求。保持 `TCP` 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。

### 缓存问题

第二次打开页面时，速度会变快，主要原因是第一次加载页面过程中，缓存了一些耗时操作。

`DNS缓存`和`页面资源`会被浏览器缓存下来。dns缓存主要就是在浏览器本地把对应ip和域名关联起来。

页面资源缓存过程，分以下情况

- 本地无缓存，继续请求web服务器，web服务器无缓存，返回数据，数据缓存本地。
- 本地缓存在生存期`Max-age`里，无需请求,直接返回本地缓存
- 本地缓存过期，请求web服务器，服务器返回304，缓存内容没有改动，刷新缓存新鲜度。

当服务器返回HTTP 响应头给浏览器时，浏览器是通过响 应头中的 Cache-Control 字段来设置是否缓存该资源，通常，我们还需要为这个资源设置 一个缓存过期时长。而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比 如上图设置的缓存过期时间是 2000 秒。

这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中 的资源给浏览器。但如果缓存过期了，浏览器则会继续发起网络请求，并且在HTTP 请求头中带上:

服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新，如果没有更新，就返回 304 状态码。如果资源有更新，服务器就直接返回最新资源给浏览器

## 导航过程

- 用户从浏览器进程里输入请求信息
- 网络进程发起 URL 请求
- 服务器响应 URL 请求之后，浏览器进程就又要开始准备渲染进程了
- 向渲染进程提交页面数据，称之为提交文档阶段
- 接收完文档信息之后，开始解析页面和加载子资源，完成页面的渲染。

### 用户输入

当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL

- 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL

- 如果是请求的URL，浏览器会根据协议规则，把这段内容加上协议，合成完整的URL

当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。此时并不会替换页面内容。因为 需要等待提交文档阶段，页面内容才会被替换。

### url请求过程

浏览器进程会通过进程间通信(`IPC`)把url请求发送至网络进程，网络进程接收到 `URL` 请求后，会在这里发起真正的 `URL` 请求流程。

- 查找本地资源，有则直接返回，无则下一步
- 进行 `DNS` 解析，获取请求域名的服务器 `IP` 地址。如果请求协议是 `HTTPS`，那么 还需要建立 `TLS` 连接。
- 建立 `TCP` 连接, 连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 `Cookie` 等数据附加到请求头中，然后向服务器发送构建的请求信息。
- 服务器接收到请求信息后，会根据请求信息生成响应数据,并发给网络进程，等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了.
- 重定向：在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 `301` 或者 `302`，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 `Location` 字段里面读取重定向的地址，然后再发起新的 `HTTP` 或者 `HTTPS` 请求，一切 又重头开始了。
- 响应数据类型处理：`content-type`告诉浏览 器服务器返回的响应体数据是什么类型，浏览器根据`content-type`来决定如何显示响应体的内容,`Content-type:text/html`告诉浏览器返回的是HTML的数据结构， `Content-Type:application/octet-stream`显示数据是字节流类型。
- 如果被判断为下载类型，导航结束，如果是html,导航继续。

### 准备渲染进程

chrome会为每一个页面分配一个渲染进程，每打开一个页面，就会配套创建一个新的渲染进程。

如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程.
同一站点:根域名加上协议,还包含了该根域名下的所有子域名和不同的端口.

### 提交文档

浏览器进程发出提交文档信息，渲染进程收到提交文档的消息后，会和网络进程建立传输数据的“管道”。等文档数据传输完毕以后，渲染进程会返回`确认提交`的消息给浏览器进程。浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

### 渲染阶段

一旦文档被提交，渲染进程便开始页面解析和子资源加载了，关于这个阶段的完整过程，我 会在下一篇文章中来专门介绍。这里你只需要先了解一旦页面生成完成，渲染进程会发送一 个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画.

## 浏览器渲染过程

HTML、CSS、JavaScript 数据，这些数据经过中间渲染 模块的处理，最终输出为屏幕上的像素。

HTML的内容是由文本和标记组成，如果需要改变文字颜色，需要用到CSS，CSS 又称为层叠样式表，是由选择器和属性组成的。

JavaScript，使用它可以使网页的内容“动”起来

### 渲染的子阶段

- 构建 DOM 树
- 样式计算
- 布局阶段
- 分层
- 绘制
- 合成
- 光栅化和合成

每个子阶段都有开始输入的内容，然后处理结果，再生成输出内容。

### 构建DOM树

构建 DOM 树的输入内容是一个非常简单的 `HTML` 文件，然后经由 `HTML` 解析器解析，最终输出树状结构的 `DOM` 。

document对象就是DOM，Dom 和HTML内容几乎是一样的,但是和 `HTML` 不同的是， `DOM` 是保存在内存中树状结构,可以通过 `JavaScript` 来查询或修 改其内容。

### 样式计算

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式

#### 把 CSS 转换为浏览器能够理解的结构

css来源： 通过link引入css文件,style标记内的css,元素的style属性内嵌的css
当渲染引擎接 收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。

#### 转换样式中的属性，使其标准化

在 `CSS` 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解,将其转换为标准值。

#### 计算出 DOM 树中每个节点的具体样式

- 规则1：CSS 继承
CSS 继承，CSS 继承就是每个 DOM 节点都包含有父节点的样式，
UserAgent样式表，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式。

- 样式层叠

层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法，

式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程 中需要遵守 CSS 的继承和层叠两个规则，这个阶段最终输出的内容是每个 DOM 节点的样 式，并被保存在 ComputedStyle 的结构内。可以通过`window.getComputedStyle(xxx)`来获取元素的样式。

### 布局阶段

算出 DOM 树中可见元素的几何位置，这个计算过程叫做布局。

Chrome 在布局阶段需要完成两个任务:创建布局树和布局计算。

#### 创建布局

DOM树中还有很多不可见的元素，还有使用了 display:none 属性的元素，在显示之前，我们还要额外地构建一棵只包含可见元素布局树。

为了构建布局树，浏览器大体上完成了下面这些工作:
遍历 DOM 树中的所有可见节点，并把这些节点加到布局中
而不可见的节点会被布局树忽略掉，如果属性包含 dispaly:none，元素也没有被包进布局树。

#### 布局计算

在有了一颗完整的布局树以后，那么接下来，就要计算布局树节点的坐标位置了。
在执行布局操作的时候，会把布局运算的结果重新写回布局树中，布局树既是输入内容也是输出内容。这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容 和输出内容区分开来

### 分层

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，已经 z-index 做 z 轴排序。为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的 图层，并生成一棵对应的图层树。
通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么 这个节点就从属于父节点的图层。每一个节点都会直接或者间接地从属于一个层。

通常满足下面两点中任 意一点的元素就可以被提升为单独的一个图层。

- 第一点，拥有层叠上下文属性的元素会被提升为单独的一层。明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等， 都拥有层叠上下文属性。
- 需要剪裁(clip)的地方也会被创建为图层。如文字过多，页面被截断。如果出现滚动条，滚动 条也会被提升为单独的层。

元素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单 独一层。

### 图层绘制

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。

渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再 把这些指令按照顺序组成一个待绘制列表。

#### 栅格化(raster)操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。

当图层的绘制列表准备好之后，主线程会把该绘制列表提交(commit)给合成线程。

图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底 部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图 层内容的话，就会产生太大的开销，而且也没有必要。基于这个原因，合成线程会将图层划分为图块(tile)。
然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执 行的。所谓栅格化，是指将图块转换为位图。
而图块是栅格化执行的最小单位。渲染进程维 护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。
通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化， 或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”， 然后将该命令提交给浏览器进程。
浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后 根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

### 一个完整的渲染流程大致可总结为如下

1. 渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的
样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令DrawQuad给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

### “重排”“重绘”和“合成”

- 更新了元素的几何属性(重排)

如果通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元 素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫 重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

- 更新元素的绘制属性(重绘)

如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引 起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程
就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

- 直接合成阶段

如果更改一个既不要布局也不要绘制的属性,渲染引擎将跳过布局和绘制，只执行后续的合成操作，这个过程叫做合成。

使用 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段， 直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并 没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

## js的执行

### 变量提升

- 在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。
- 在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义
时的值。
- 在一个函数定义之前使用它，不会出错，且函数能正确执行。

#### 变量声明

所谓的变量提升，指在 `JavaScript` 代码执行过程中，`javaScript`引擎把变量的声明部分和函数的声明部分提升到代码开头行为。变量提升后，会给变量设置一个默认值，这个值就是 `undefined`

```javascript
var myName = 'pengYue'
// 上面的变量可以拆解为两部分
var myName
myName = "pengYue"
```

#### 函数声明

```javascript
// 具名函数
function foo() {
 console.log('foo)
}
// 函数变量，先声明变量bar，再把匿名函数赋值给bar
var bar = function(){
 console.log('bar')
}
```

#### javaScript 代码执行过程

变量和函数声明在代码里面的位置不会改变，而是在编译阶段被JavaScript引擎放入内存。

- 编译阶段

在输入一段代码，经过编译后，会生成两部分内容：执行上下文(Execution context)和可执行代码，执行上下文是JavaScript执行一段代码时的运行环境。
在执行上下文中，存在一个变量环境的对象。该对象中保存了变量提升的内容。

- 执行阶段

javaScript 引擎开始执行可执行代码，按照顺序一行一行的执行。变量会到变量环境中寻找。

::: tip
从最简单的理解来看，编译阶段，构建变量，放入变量执行环境中。执行阶段，一行一行执行，从变量环境中找到变量。
:::

## JavaScript的执行栈

在执行过程中，会编译全局代码并创建全局执行上下文，在整个页面的生存周期中，全局执行上下文只有一份。

当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况 下，函数执行结束之后，创建的函数执行上下文会被销毁。

当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

### 调用栈

调用栈就是用来管理函数调用关系的一种数据结构。在执行上下文创建好后， JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。

#### 函数调用

函数调用就是运行一个函数，在执行函数之前，会创建全局执行上下文。同时，函数本身也存在执行上下文。所以函数执行过程中会存在多个执行上下文。javaScript通过栈来管理执行上下文。

#### 栈溢出

当入栈的执行上下文超过一定数目，JavaScript引擎就会报错，我们把这种错误叫做栈溢出。

调用栈有两个指标，最大栈容量和最大调用深度，满足其中任意一个就会栈溢出。


