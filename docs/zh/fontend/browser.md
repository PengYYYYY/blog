# 浏览器相关学习笔记

## 单进程浏览器与多进程浏览器

### 进程与线程

一个进程就是一个程序的运行实例。启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码，运行中的数据和一个执行任务的主线程，一个这样的运行环境叫进程。

线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

进程与线程之间的关系：

- 进程中的任意一线程执行出错，都会导致整个进程崩溃
- 线程之间共享进程中的数据
- 当一个进程关闭之后，操作系统会回收进程所占用的内存
- 进程之间的内容相互隔离，如果需要进程中的通信，就需要使用用于进程间通信(IPC)的机制了。

### 单进程浏览器

单进程浏览 器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、 JavaScript 运行环境、渲染引擎和页面等。导致浏览器`不稳定`、`不流畅`和`不安全`。

- 不稳定：浏览器插件容易出问题，出问题以后会导致整个进程的崩溃。渲染引擎模块在引入一些复杂的JavaScript代码时也会崩溃。

- 不流畅：由于单进程模型，在同一时刻中，只能有一个模块运行。在耗时脚本中，在其执行过程中，会独占整个线程，导致其他任务无法执行，会造成卡顿的现象。页面的内存泄漏也是单进程变慢的一个重要原因。运行一个复杂点的页面再关闭页面，会存在 内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得 越慢。

- 不安全：通过插件可以获取到操作系统的任意资源，所以当运行一个插件时，也就意味着这个插件能完全操控操作系统。如果是恶意插件，则会引起安全问题。同样的，页面的恶意脚本也可以进行此类操作

### 多进程浏览器

多进程浏览器架构中，页面是运行在单独的渲染进程中的，同时页面中的插件也运行在单独的插件进程中，进程之间通过`ipc(inter-Process Communication)`机制进行通信

#### 如何解决不稳定的问题

由于进程是相互隔离的，所以当一个页面或者插件崩溃 时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就 完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。

#### 如何解决不流畅问题

JavaScript 也是运行在渲染进程中 的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影 响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的

对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收。

#### 如何解决安全问题

采用多进程架构的额外好处是可以使用`安全沙箱`，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里 面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。

### 最新的多进程架构

最新的 Chrome 浏览器包括:1 个浏览器(Browser)主进程、1 个 GPU 进程、1 个网络(NetWork)进程、多个渲染进程和多个插件进程。

- 浏览器进程: 主要负责界面显示、用户交互、子进程管理，同时提供存储等功能.
- 渲染进程: 核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页， 排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会 为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下.
- GPU 进程: 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷 是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘 制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- 网络进程: 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面 的，直至最近才独立出来，成为一个单独的进程。
- 插件进程: 主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保 证插件进程崩溃不会对浏览器和页面造成影响。

打开一个chrome页面：最少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，如果有运行插件的话，还需要一个插件进程。

### 多进程架构带来的问题

- 更高的资源占用： 因为每个进程都会包含公共基础结构的副本(如 JavaScript 运行环 境)，这就意味着浏览器会消耗更多的内存资源。
- 更复杂的体系架构： 浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已 经很难适应新的需求了。

### 未来面向服务的架构

面向服务的架构(Services Oriented Architecture，简称SOA)，把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统 底层服务。如果把Chrome抽象为`便携式操作系统`，Chrome 基础服务便可以被视为该操作系统的`基础`系统服务层。

同时`Chrome`还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服 务，但是如果在资源受限的设备上，Chrome 会将很多服务整合到一个进程中，从而节省内存占用。

## 浏览器的网络请求

浏览器端发起 HTTP 请求流程

- 构建请求

```shell
GET /index.html HTTP1.1
```

- 查找缓存

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。命中缓存，返回该资源的副本，并直接结束请求。否则继续请求。

- 准备 IP 地址和端口

第一步浏览器会请求DNS 返回域名对应的IP。当 然浏览器还提供了DNS数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。拿到IP 之后，接下来就需要获取端口号了。通常情况下，如果URL没有特别指明端口 号，那么HTTP协议默认是80端口。

- 等待TCP队列

Chrome有个机制，同一个域名同时最多只能建立6个TCP连接， 如果在同一个域名下同时有10个请求发生，其中4个请求会进入排队等待状态，直到进行中的请求完成。

- 建立TCP连接

排队等待结束后，浏览器通过TCP与服务器连接

- 发送 HTTP 请求

首先浏览器会向服务器发送请求行，包括了请求方法，请求URI,HTTP协议。发送请求行就是告诉服务器需要什么资源。
发送请求体，把信息告诉服务器，发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础 信息告诉服务器。

- 服务端处理HTTP请求

服务器会返回响应行，包括协议版本和状态码，发送响应体

- 断开连接

一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，当配置了`Connection:Keep-Alive`属性,tcp连接会被保持打开状态，这样浏览器可以通过同一个TCP连接发送请求。保持 `TCP` 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。

### 缓存问题

第二次打开页面时，速度会变快，主要原因是第一次加载页面过程中，缓存了一些耗时操作。

`DNS缓存`和`页面资源`会被浏览器缓存下来。dns缓存主要就是在浏览器本地把对应ip和域名关联起来。

页面资源缓存过程，分以下情况

- 本地无缓存，继续请求web服务器，web服务器无缓存，返回数据，数据缓存本地。
- 本地缓存在生存期`Max-age`里，无需请求,直接返回本地缓存
- 本地缓存过期，请求web服务器，服务器返回304，缓存内容没有改动，刷新缓存新鲜度。

当服务器返回HTTP 响应头给浏览器时，浏览器是通过响 应头中的 Cache-Control 字段来设置是否缓存该资源，通常，我们还需要为这个资源设置 一个缓存过期时长。而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比 如上图设置的缓存过期时间是 2000 秒。

这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中 的资源给浏览器。但如果缓存过期了，浏览器则会继续发起网络请求，并且在HTTP 请求头中带上:

服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新，如果没有更新，就返回 304 状态码。如果资源有更新，服务器就直接返回最新资源给浏览器

## 导航过程

- 用户从浏览器进程里输入请求信息
- 网络进程发起 URL 请求
- 服务器响应 URL 请求之后，浏览器进程就又要开始准备渲染进程了
- 向渲染进程提交页面数据，称之为提交文档阶段
- 接收完文档信息之后，开始解析页面和加载子资源，完成页面的渲染。

### 用户输入

当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL

- 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL

- 如果是请求的URL，浏览器会根据协议规则，把这段内容加上协议，合成完整的URL

当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。此时并不会替换页面内容。因为 需要等待提交文档阶段，页面内容才会被替换。

### url请求过程

浏览器进程会通过进程间通信(`IPC`)把url请求发送至网络进程，网络进程接收到 `URL` 请求后，会在这里发起真正的 `URL` 请求流程。

- 查找本地资源，有则直接返回，无则下一步
- 进行 `DNS` 解析，获取请求域名的服务器 `IP` 地址。如果请求协议是 `HTTPS`，那么 还需要建立 `TLS` 连接。
- 建立 `TCP` 连接, 连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 `Cookie` 等数据附加到请求头中，然后向服务器发送构建的请求信息。
- 服务器接收到请求信息后，会根据请求信息生成响应数据,并发给网络进程，等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了.
- 重定向：在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 `301` 或者 `302`，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 `Location` 字段里面读取重定向的地址，然后再发起新的 `HTTP` 或者 `HTTPS` 请求，一切 又重头开始了。
- 响应数据类型处理：`content-type`告诉浏览 器服务器返回的响应体数据是什么类型，浏览器根据`content-type`来决定如何显示响应体的内容,`Content-type:text/html`告诉浏览器返回的是HTML的数据结构， `Content-Type:application/octet-stream`显示数据是字节流类型。
- 如果被判断为下载类型，导航结束，如果是html,导航继续。

### 准备渲染进程

chrome会为每一个页面分配一个渲染进程，每打开一个页面，就会配套创建一个新的渲染进程。

如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程.
同一站点:根域名加上协议,还包含了该根域名下的所有子域名和不同的端口.

### 提交文档

浏览器进程发出提交文档信息，渲染进程收到提交文档的消息后，会和网络进程建立传输数据的“管道”。等文档数据传输完毕以后，渲染进程会返回`确认提交`的消息给浏览器进程。浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

### 渲染阶段

一旦文档被提交，渲染进程便开始页面解析和子资源加载了，关于这个阶段的完整过程，我 会在下一篇文章中来专门介绍。这里你只需要先了解一旦页面生成完成，渲染进程会发送一 个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画.

## 浏览器渲染过程

HTML、CSS、JavaScript 数据，这些数据经过中间渲染 模块的处理，最终输出为屏幕上的像素。

HTML的内容是由文本和标记组成，如果需要改变文字颜色，需要用到CSS，CSS 又称为层叠样式表，是由选择器和属性组成的。

JavaScript，使用它可以使网页的内容“动”起来

### 渲染的子阶段

- 构建 DOM 树
- 样式计算
- 布局阶段
- 分层
- 绘制
- 合成
- 光栅化和合成

每个子阶段都有开始输入的内容，然后处理结果，再生成输出内容。

### 构建DOM树

构建 DOM 树的输入内容是一个非常简单的 `HTML` 文件，然后经由 `HTML` 解析器解析，最终输出树状结构的 `DOM` 。

document对象就是DOM，Dom 和HTML内容几乎是一样的,但是和 `HTML` 不同的是， `DOM` 是保存在内存中树状结构,可以通过 `JavaScript` 来查询或修 改其内容。

### 样式计算

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式

#### 把 CSS 转换为浏览器能够理解的结构

css来源： 通过link引入css文件,style标记内的css,元素的style属性内嵌的css
当渲染引擎接 收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。

#### 转换样式中的属性，使其标准化

在 `CSS` 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解,将其转换为标准值。

#### 计算出 DOM 树中每个节点的具体样式

- 规则1：CSS 继承
CSS 继承，CSS 继承就是每个 DOM 节点都包含有父节点的样式，
UserAgent样式表，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式。

- 样式层叠

层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法，

式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程 中需要遵守 CSS 的继承和层叠两个规则，这个阶段最终输出的内容是每个 DOM 节点的样 式，并被保存在 ComputedStyle 的结构内。可以通过`window.getComputedStyle(xxx)`来获取元素的样式。

### 布局阶段

算出 DOM 树中可见元素的几何位置，这个计算过程叫做布局。

Chrome 在布局阶段需要完成两个任务:创建布局树和布局计算。

#### 创建布局

DOM树中还有很多不可见的元素，还有使用了 display:none 属性的元素，在显示之前，我们还要额外地构建一棵只包含可见元素布局树。

为了构建布局树，浏览器大体上完成了下面这些工作:
遍历 DOM 树中的所有可见节点，并把这些节点加到布局中
而不可见的节点会被布局树忽略掉，如果属性包含 dispaly:none，元素也没有被包进布局树。

#### 布局计算

在有了一颗完整的布局树以后，那么接下来，就要计算布局树节点的坐标位置了。
在执行布局操作的时候，会把布局运算的结果重新写回布局树中，布局树既是输入内容也是输出内容。这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容 和输出内容区分开来

### 分层

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，已经 z-index 做 z 轴排序。为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的 图层，并生成一棵对应的图层树。
通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么 这个节点就从属于父节点的图层。每一个节点都会直接或者间接地从属于一个层。

通常满足下面两点中任 意一点的元素就可以被提升为单独的一个图层。

- 第一点，拥有层叠上下文属性的元素会被提升为单独的一层。明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等， 都拥有层叠上下文属性。
- 需要剪裁(clip)的地方也会被创建为图层。如文字过多，页面被截断。如果出现滚动条，滚动 条也会被提升为单独的层。

元素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单 独一层。

### 图层绘制

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。

渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再 把这些指令按照顺序组成一个待绘制列表。

#### 栅格化(raster)操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。

当图层的绘制列表准备好之后，主线程会把该绘制列表提交(commit)给合成线程。

图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底 部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图 层内容的话，就会产生太大的开销，而且也没有必要。基于这个原因，合成线程会将图层划分为图块(tile)。
然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执 行的。所谓栅格化，是指将图块转换为位图。
而图块是栅格化执行的最小单位。渲染进程维 护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。
通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化， 或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”， 然后将该命令提交给浏览器进程。
浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后 根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

### 一个完整的渲染流程大致可总结为如下

1. 渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的
样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令DrawQuad给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

### “重排”“重绘”和“合成”

- 更新了元素的几何属性(重排)

如果通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元 素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫 重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

- 更新元素的绘制属性(重绘)

如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引 起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程
就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

- 直接合成阶段

如果更改一个既不要布局也不要绘制的属性,渲染引擎将跳过布局和绘制，只执行后续的合成操作，这个过程叫做合成。

使用 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段， 直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并 没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

## js的执行

### 变量提升

- 在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。
- 在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义
时的值。
- 在一个函数定义之前使用它，不会出错，且函数能正确执行。

#### 变量声明

所谓的变量提升，指在 `JavaScript` 代码执行过程中，`javaScript`引擎把变量的声明部分和函数的声明部分提升到代码开头行为。变量提升后，会给变量设置一个默认值，这个值就是 `undefined`

```javascript
var myName = 'pengYue'
// 上面的变量可以拆解为两部分
var myName
myName = "pengYue"
```

#### 函数声明

```javascript
// 具名函数
function foo() {
 console.log('foo)
}
// 函数变量，先声明变量bar，再把匿名函数赋值给bar
var bar = function(){
 console.log('bar')
}
```

#### javaScript 代码执行过程

变量和函数声明在代码里面的位置不会改变，而是在编译阶段被JavaScript引擎放入内存。

- 编译阶段

在输入一段代码，经过编译后，会生成两部分内容：执行上下文(Execution context)和可执行代码，执行上下文是JavaScript执行一段代码时的运行环境。
在执行上下文中，存在一个变量环境的对象。该对象中保存了变量提升的内容。

- 执行阶段

javaScript 引擎开始执行可执行代码，按照顺序一行一行的执行。变量会到变量环境中寻找。

::: tip
从最简单的理解来看，编译阶段，构建变量，放入变量执行环境中。执行阶段，一行一行执行，从变量环境中找到变量。
:::

## JavaScript的执行栈

在执行过程中，会编译全局代码并创建全局执行上下文，在整个页面的生存周期中，全局执行上下文只有一份。

当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况 下，函数执行结束之后，创建的函数执行上下文会被销毁。

当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

### 调用栈

调用栈就是用来管理函数调用关系的一种数据结构。在执行上下文创建好后， JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。

#### 函数调用

函数调用就是运行一个函数，在执行函数之前，会创建全局执行上下文。同时，函数本身也存在执行上下文。所以函数执行过程中会存在多个执行上下文。javaScript通过栈来管理执行上下文。

#### 栈溢出

当入栈的执行上下文超过一定数目，JavaScript引擎就会报错，我们把这种错误叫做栈溢出。

调用栈有两个指标，最大栈容量和最大调用深度，满足其中任意一个就会栈溢出。

## 块级作用域

作用域是指在程序中定义变量的区域，该区域决定了变量的生命周期。作用域就是变量与函数的可访问范围，作用域控制着变量和函数的可见性和生命周期。

- 全局作用域：其中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
- 函数作用域：在函数内部定义的变量或函数，并且定义的函数只能在函数内部被访问。函数执行结束，就会被销毁。
- 块级作用域：使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句， 甚至单独的一个{}都可以被看作是一个块级作用域。

### 变量提升带来的问题

- 变量容易在不被察觉的情况下被覆盖掉
- 一些本来应该销毁的代码不会被销毁

### 块级作用域的实现

使用 let 关键字声明的变量是可以被改变 的，而使用 const 声明的变量其值是不可以被改变的。

函数内部通过var声明的变量，在编译阶段全部被存入变量环境中。通过let和const声明的变量会放到词法环境中。在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶。当作用域执行完成之后，该作用域的信息 就会从栈顶弹出，这就是词法环境的结构。在使用变量时，需要在词法环境和变 量环境中查找变量 a 的值。沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继 续在变量环境中查找。

### 作用域链

在每个执行上下文中，都包含一个外部引用。用来指向外部的执行上下文，外部应用称为outer。

在函数的执行过程中，按照作用域链查找变量。在分析作用域链的时候，需要结合词法环境和变量环境。

## JavaScript 中的 this

执行上下文中包含了变量环境、词法环境、外部环境。this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this。

与执行上下文对应,this有三种.

- 全局执行上下文
- 函数执行上下文
- eval 执行上下文

全局执行上下文中的 this 是指向 window 对象。

函数执行上下文，指向他的执行上下文，也就是谁执行它，this就指向谁。

### 设置函数执行上下文中的 this 值

1: 通过函数的call方法设置它的执行上下文，同样的还有，bind, apply。

call,bind,apply的区别

- bind只是绑定执行上下文，并不执行函数，call,与apply立即执行
- call，bind传入多个参数，apply传入两个参数。第一个参数都为this的指向对象。

2: 通过对象调用方法设置

在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。
使用对象来调用其内部的一个方法，该方法的 this 是指向 对象本身的。

3: 通过构造函数中设置

执行 new CreateObj() 创建了对象时，JavaScript 引擎做了如下四件事:

- 首先创建了一个空对象 tempObj
- 接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象;
- 然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象;
- 最后返回 tempObj 对象。

### 在使用 this 时

- 当函数作为对象的方法调用时，函数中的 this 就是该对象;
- 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window;
- 嵌套函数中的 this 不会继承外层函数的 this 值。

## v8

javascript 是动态类型的语言，在运行过程中需要检查数据类型。支持在运行过程中的隐式类型转换。他是一种弱类型的、动态的语言。

- 弱类型：意味着不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型， JavaScript 引擎在运行代码的时候自己会计算出来。

- 动态：意味着可以使用同一个变量保存不同类型的数据。

### javascript的8种基本类型

|类型 | 时间复杂度 |
|----|-----|
|Boolean|只有true和false|
|Null|只有一个null|
|Undefined|没有赋值的变量有个默认值undefined。变量提升默认值也为undefined|
|Number|数字类型,有范围|
|BigInt|数字类型,无范围|
|String|用于表示文本数据|
|Symbol|符号唯一而且不可修改，通常用来作为Object的key|
|Object|在JavaScript中，对象可以被看作是一组属性的集合|

### 内存空间

在JavaScript的执行过程中，主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。

#### 栈空间和堆空间

在执行过程中，栈空间用来维护函数的执行上下文，堆空间用来保存引用类型数据。

通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，堆空间很大，能存放很多大的数据。

### 垃圾回收

- 在调用栈中，有一个记录 当前执行状态的指针(称为 ESP)，函数的执行上下文一旦被执行后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。在调用另外的函数时，这块内容会被直接覆盖掉，用来存放另外一个函 数的执行上下文。

- 堆中的垃圾回收：回收堆中的垃圾数据，需要用到JavaScript引擎中的垃圾回收器。
- 代际假说：第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问;第二个是不死的对象，会活得更久。

### 新生代和老生代

新生代中存放的是生存时间短的对 象，老生代中存放的生存时间久的对象。
新生区通常只支持 1~8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器

- 副垃圾回收器，主要负责新生代的垃圾回收。
- 主垃圾回收器，主要负责老生代的垃圾回收。

### 垃圾回收的工作流程

- 第一步：标记空间中活动对象和非活动对象。标记活着的和死的。
- 第二步：回收非活动对象所占据的内存。回收死的。
- 第三步：内存整理，一般来说，频繁回收对象后，内存中就会存在大量不连续空间，这些不连续的内存空间称为内存碎片。

### 副垃圾回收器

小的对象会分配到新生区，这个区域虽然不大，但是垃圾回收还是比较频繁的。

新生代中用 `Scavenge` 算法,把新生代空间对半划分为两 个区域，一半是对象区域，一半是空闲区域.新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

在垃圾回收过程中，首先要对对象区域中的垃圾做标记;标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。

因为需要开辟两块空间，所以一般新生区都会设置的比较小。因为空间不大，所以很容易被存活的对象装满整个区域。JavaScript引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

### 主垃圾回收器

主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。一个是对象占用空间大，另一个是对象存活时间长。

主垃圾回收器是采用标记 - 清除(Mark-Sweep)的算法进行垃圾回收。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称活动对象，没有到达的元素就可以判断为垃圾数据。

在垃圾回收处理过程中，先使用标记清除算法把垃圾清除，再使用标记整理算法把碎片进行整理。

### 全停顿

由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来。待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿(Stop-The-World)。

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行。这个算法称为增量标记。使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执 行时间比较短，可以穿插在其他的 JavaScript 任务中间执行。

### V8如何执行代码

编译器(Compiler)、解释器(Interpreter)、抽象语法树(AST)、字节码 (Bytecode)、即时编译器(JIT)

#### 编译器和解释器

- 编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能 读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译。比如 C/C++、GO 等都是编译型语言。
- 而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。

- 编译器流程：源代码 -词法分析，语法分析-> AST -词义分析> 中间代码 -代码优化> 二进制文件 -直接执行> 执行
- 解释器流程：源代码 -词法分析，语法分析-> AST -词义分析> 字节码 -解释执行> 执行

#### V8执行代码流程

- 生成抽象语法树和执行上下文，将源代码转化成抽象语法树，并生成执行上下文，
  - 分词(tokenize):将一行行的源码拆解成一个个 `token` 指的是语法上不可能再分的、最小的单个字符或字符串。
  - 解析(parse): 将生成的 token 数据，根据语法规则转为 AST
- 生成字节码：解释器 Ignition 根据 AST生成字节码，并解释执行字节码。一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，但是V8 需要消耗大量的内存来存放转换后的机器码。字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需 要通过解释器将其转换为机器码后才能执行。
- 执行代码： 在执行字节码的过程中，如果发现有热点代码(HotSpot)，比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。

### JavaScript 的性能优化

主要关注以下三点内容

- 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面 快速响应交互;
- 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程;
- 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。

## 页面循环系统

## 网络安全

网络安全必不可少

### 同源策略

如果两个 `URL` 的协议、域名和端口都相同，我们就称这两个 `URL` 同源。

两个相同的源之间是可以相互访问资源和操作 DOM ,两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约。
同源策略表现在DOM、Web 数据和网络这三个层面。

- DOM层面：同源策略限制了来自不同的Javascript脚本对当前DOM读写的操作。
- 数据层面：同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。
- 网络层面：同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。

#### 安全和便利性的权衡

不过安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用。

浏览器出让了同源策略的哪些安全性

- 页面中可以嵌入第三方资源：web世界是开放的，可以接入任何资源，同源策略要让一个页面的所有资源都来自于同一个源，会带来XSS攻击。注入外部的恶意脚本。为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。CSP的核心思想就是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。
- 跨域资源共享和跨文档消息机制：引入了跨域资源共享（CORS），使用该机制可以进行跨域访问控制。

|  规则   | 问题  | 策略  |
|  ----  | ----  | ----  |
| 页面中可以引用第三方资源 | 暴露了很多诸如 XSS 的安全问题 | 引入了 CSP 来限制其自由程度 |
| 同源策略 | 使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的 |跨域资源共享策略(CORS) |
| 同源策略 | 两个不同源的 DOM 是不能相互操纵的 | 跨文档消息机制(postMessage) |

### XSS攻击(跨站脚本攻击)

XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。

#### 恶意脚本可以做的事情

- 窃取 Cookie 信息：恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器。
- 监听用户行为：恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。
- 修改 DOM伪造假的登录窗口
- 在页面内生成浮窗广告

#### 恶意脚本是怎么注入的

通常情况下，主要有存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击三种方式来注入恶意脚本。

> 存储型 XSS 攻击

- 黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
- 用户向网站请求包含了恶意 JavaScript 脚本的页面；
- 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。

> 反射型 XSS 攻击

- 用户将一段含有恶意代码的请求提交给 Web 服务器
- Web 服务器接收到请求时，又将恶意代码反射给了浏览器端

> 基于 DOM 的 XSS 攻击

基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。其原理就是修改页面中的DOM。

#### 如何阻止XSS攻击

存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器，这两种类型的漏洞是服务端的安全漏洞。
而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞。

#### 常用的阻止 XSS 攻击的策略

- 服务器对输入脚本进行过滤或转码

- 实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能

1. 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；

2. 禁止向第三方域提交数据，这样用户数据也不会外泄；

3. 禁止执行内联脚本和未授权的脚本；
4. 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。

- 使用 HttpOnly 属性

1. 由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。
2. 使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie

### CSRF攻击

Cross-site request forgery(跨站请求伪造)，指的是黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户登录状态发起跨站请求。

#### 攻击流程

- 用户发起登录请求，服务器返回一些登录状态给浏览器，这些信息包括了cookie,session等，这样用户在浏览器中就属于登录状态了。

- 接着，黑客通过各种手段去引诱用户打开他的链接，在黑客的链接中，黑客会编写好一个邮件过滤器，通过邮件网站提供的HTTP设置设置好新的邮件过滤功能。该过滤会将所有邮箱都转发到黑客的邮箱中。

- 最后，去服务商重置用户的密码。

#### 攻击方案

- 自动发起get请求，将接口放到img标签中，加载页面时自动发起get请求.

- 自动发起post请求，直接提交一个表单。

- 引诱用户点击恶意链接。

### 如何防止CSRF攻击

发起CSRF的三个必要条件

- 目标站点一定有CSRF漏洞
- 用户要登录过目标站点，并且在浏览器上保持该站点的登录状态
- 需要用户打开一个第三方站点，可以是黑客站点，也可以是一些论坛。

避免CSRF

- 充分利用好Cookie的SameSite属性：strict最为严格:完全禁止第三方cookie。Lax宽松:Get请求才会携带，None在任何情况下都会发送。

- 验证请求的来源站点：利用请求头中的 `referer` 字段，该字段记录了该`http`请求的来源地址。Origin属性只包含了域名信息，并没有包含具体的URL路径，这是Origin和Referer的主要区别。

- CSRF TOKEN：类似于JWT。

### CSP常用设置

- 内容均来自同一站点：`Content-Security-Policy: default-src 'self'`
- 允许内容来自信任的域名及其子域名: `Content-Security-Policy: default-src 'self' *.trusted.com`
- 允许网页应用的用户在他们自己的内容中包含来自任何源的图片：`Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com`
- 一个线上银行网站的管理者想要确保网站的所有内容都要通过SSL方式获取，以避免攻击者窃听用户发出的请求：`Content-Security-Policy: default-src https://onlinebanking.jumbobank.com`
- 一个在线邮箱的管理者想要允许在邮件里包含HTML，同样图片允许从任何地方加载，但不允许JavaScript或者其他潜在的危险内容(从任意位置加载):`Content-Security-Policy: default-src 'self' *.mailsite.com; img-src *`

>对策略进行测试

CSP可以部署为报告(report-only)模式。在此模式下，CSP策略不是强制性的，但是任何违规行为将会报告给一个指定的URI地址。此外，一个报告模式的头部可以用来测试一个修订后的未来将应用的策略而不用实际部署它。

`Content-Security-Policy-Report-Only: policy`
