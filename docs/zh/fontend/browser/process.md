# 浏览器从输入url到页面加载的过程

## 准备动作

输入后，先做url匹配，从书签，历史记录等地方，找到已经输入的字符串可能匹配的URL，然后显示出来。让你做选择。

## 开始加载

当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容。

## URL 请求过程

进入了页面资源请求过程。这时，浏览器进程会通过进程间通信(IPC)把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。

- 网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给 浏览器进程;如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一 步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么 还需要建立 TLS 连接。

- 利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、 请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构 建的请求信息。

- 服务器接收到请求信息后，会根据请求信息生成响应数据(包括响应行、响应头和响应体等信息)，发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。

## 重定向

在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头 的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。

## 响应数据类型处理

- Content-Type： 它告诉浏览 器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如 何显示响应体的内容。

- 响应头中的 Content-type 字段的值是 text/html，这就是告诉浏览器， 服务器返回的数据是HTML 格式。
- Content-Type 的值是 application/octet-stream，显示数据是字节流类型的，通常情况下，浏览器会按照下载类型来处理该请求。

## 准备渲染进程

Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就 会配套创建一个新的渲染进程。

通常情况下，打开新的页面都会使用单独的渲染进程;
如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的 渲染进程;如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。

同一站点：同一站点”定义为根域名(xxxx.org)加上协议(例如，https:// 或者 http://)，还包含了该根域名下的所有子域名和不同的端口

## 提交文档

“提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。

等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。

浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地
址栏的 URL、前进后退的历史状态，并更新 Web 页面。

## 渲染阶段

渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线。

按照渲染的时间顺序，流水线可分为如下几个子阶段: 构建 DOM 树、样式计算、布局阶 段、分层、绘制、分块、光栅化和合成。

## 构建 DOM 树

浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM树。

解析是将一个元素通过一定的方式转换成另一种形式。 比如 html 的解析。首先要明确，html 下载到浏览器的表现形式就是 包含字符串的文件。浏览器将 html 文件里面的字符串读取到内存中，按照 html 规则，对字符串进行取词编译，将字符串转化成另一种易于表达的数据结构。我们看下一段代码：

## 样式计算

### 把 CSS 转换为浏览器能够理解的结构

CSS 样式来源主要有三种:

- 通过 link 引用的外部 CSS 文件
- `<style>`标记内的 CSS
- 元素的 style 属性内嵌的 CSS

当渲染引擎接 收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构—— styleSheets。

### 转换样式表中的属性值，使其标准化

现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。

CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易 被渲染引擎理解。所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值。

### 计算出 DOM 树中每个节点的具体样式

CSS 继承就是每个 DOM 节点都包含有父节点的样式。所有子节点都继承了父节点样式。

这里需要特别提下 UserAgent 样式， 它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式。

## 布局阶段

### 创建布局树

为了构建布局树，浏览器大体上完成了下面这些工作:

- 遍历 DOM 树中的所有可见节点，并把这些节点加到布局中;
- 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进 布局树。

### 布局计算

在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容 也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容 和输出内容区分开来。

## 分层

如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的 图层，并生成一棵对应的图层树(LayerTree)。

浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。

并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么 这个节点就从属于父节点的图层。

满足下面两点中任意一点的元素就可以被提升为单独的一个图层。

- 第一点，拥有层叠上下文属性的元素会被提升为单独的一层。
- 第二点，需要剪裁(clip)的地方也会被创建为图层。

## 图层绘制

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的?

渲染引擎实现图层的绘制，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

当图层的绘制列表准备好之后，主线程会把该绘制列表提交(commit)给合成线程。

## 完整的渲染流程

1. 渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令DrawQuad给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

## 重排，重绘，合成

### 更新了元素的几何属性(重排)

如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元 素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫 重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

### 更新元素的绘制属性(重绘)

接下来，我们再来看看重绘，比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会怎样调整呢?你可以参考下图:

从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高 一些。

### 直接合成阶段

那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢?渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。

我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段， 直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并 没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。
